<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年总结]]></title>
    <url>%2F2020%2F01%2F21%2F2019%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2019年过去，今年第一次跳槽，也完成了一些其他事情，想写一年的总结，记录当前的想法。 第一次跳槽 查询了信用报告 手术 了解中医 弟弟高三退学 总结 我完成了哪些事情 2019年我完成了一些对我来说，比较大的事情吧： 第一次跳槽 查询了信用报告 做了一个手术 了解中医和现代医学 对弟弟在高三退学，感到失望 第一次跳槽 毕业就进入长虹工作，感觉长虹在管理上还是挺好的，虽然算是国企，也没有感受到人家说的国企的官僚主义啊、人浮于事啊什么的，也许是我太小虾米或者待的时间才两年吧。感觉在管理上挺好的，偶尔周末加班，没有996，领导也好，有事找领导也是很快找到，就是工资没有外面有竞争者力，然后7月份就离职了。这个月本来要发季度奖的，然后离职就没有了，当时没有考虑到这个问题，但是又预约了一个手术，不想让更多人知道，奖金没有也离职了。看来以后离职要选恰当的时机，不然可能该得的福利，企业不会给你。长虹的缺点是，薪资低，亲戚说我读了大学还蹲在电子厂，还那么点工资，就千方百计催我考公务员，跳槽后薪水涨了，极少提公务员了。 在长虹工作，只有我一个人写前端，前期使用jQuery、BS等传统技术开发，同时维护老系统，需求不复杂，开发起来挺好的，高效，再者这些技术后台同事比较了解一些，有个吧需求，他们也能够实现。后来使用vue开发新的项目，就只有我一个人弄了，没人懂前端框架。vue 使用丝滑，纯数据驱动，高效，复杂的需求比jQuery容易实现多了。前后端分离开发，混合部署，隐约感觉我们的开发流程很有问题，比较容易扯皮，和网上流行的分离开发、持续部署等开发流程感觉还差很多，但是我们都不没有这种开发模式的经验，再加上我的 vue 经验少，每次和后台对接，都扯皮啊，后台在绵阳，沟通起来，太难了。完成了第一期，然后发现第二期和第一期关系不太大，没有需求文档，比较难以明确，甚至接口文档也不完善。后台写的接口文档，也毫无章法，不具备语义，后来我使用 RESTful,写了文档，有一个大概的共识，才开始写代码。 悲剧的是，后来长虹优化人员，后台项目让成都同事接手，才发现使用的技术太陈旧了，难以调试和阅读，后台了解需求什么的，又扯皮了几天。经过20多天，总算达到测试状态了，打通了和电视端的功能。 在长虹工作两年，也随便做了一些和智能家居相关的项目，对智能家居和语音交互等有点点感性的认识，还处在探索阶段，像智能手机一样达到很好的体验，市场认可，还要不少时间吧，未来凡是通电的，都会通网，交互方式也会改变。 找工作时，面了一些公司，都会问你对 996 的看法，赶项目进度啥的，看来加班是普遍的情况，我之前还以为能遇到一些加班不那么严重的公司。而且，给的待遇没有达到期望，所以拒了。也面蚂蚁金服，面试比较接地气，没玩什么虚的，技术没到期望，over 了。第一次跳槽，发现外包公司很多啊，各种给打电话，而且待遇还可以，比要你996，待遇还不满意的小团队公司好些，就冲着工资去面试了几个。最后入职一家离我很近，不要搬家的，在业务方的开发流程、工具的都做得不错的公司。入职后，发现这样的开发流程比在长虹要舒服得多，他们的工具链做得很完善，文档、代码规范啥的，做得挺好的，也有在百度、阿里、IBM工作过的大佬评审代码。 第一次跳槽，感觉学历还是那么重要啊，很多职位要求985、211的。学历就这样了，只能加强一下技术深度什么的了。 查询了信用报告 因为想看看用了网贷的表弟的信用报告，就去学习查询了一下自己的信用报告，信用良好，在支付宝的借贷记录都在里面了，有空专门写一下。 手术 离职也是因为一个手术的原因，所以没有提前找下家。离职后待业两个月，做了手术再去找的工作。第一次做这么大手术，担心出什么意外可咋整，而且几乎没告诉任何人。没想到，手术很快，医生技术不错，术后没有不适，很快好了。 了解中医 因为谭秦东事件，注意到中药。之前我从来没思考过中药到底有没有效果，或者如何判断药物有无效果的问题，然后顺便了解中医和现代医学，惊讶地发现中医理论和风水理论有交集，太荒谬了，接着又看了中医争议的百年历史，了解一些我们国家现代医药的发展现状。2020年了，还用这些伪科学或者不科学的医学来治病，难怪现代医药发展慢，算时代的悲哀。 了解中医，会随着了解很多问题，比如我们的民族文化中的糟粕，我们的教育，国人的科学素养，儒家思想的禁锢等。中医使我第一次比较认真得思考世界观、人生观、科学、宗教等之前没特别关注过的，因为中医和我读了这么多年的“科学”非常冲突，起码中医理论和科学是格格不入的，理清楚中医和文化、中医和儒家、中医理论的起源等才会明白中医为何如何荒谬且崇古不变。 弟弟高三退学 高三退学，太不明智了。不好好学习，沉迷直播，以为能赚大钱了，还自我感觉良好了。让其好好学习，别搞什么音乐，因为那条路他难以走通，却不听，说什么牛顿、爱因斯坦当时xxx的，学历有什么重要的，我学历比马云高，没马云赚钱什么的，感觉好无知，完全不是一个高三学生说的。在他看来，读书完全是为了赚钱，被那点直播赚的零花钱蒙蔽了双眼，任何人的话都听不进去。 深入思考这些问题，发现这和我家的家庭教育很相关，父母从来没有告诉过孩子读书为了什么，在教育孩子方面，他们是无能为力的，甚至很多做法是错误的。后来一联想她姐说北大的垃圾，我考一本垃圾，一个高三学生，还觉得北大垃圾，妈妈没感到震惊，反而护短，因此弟弟也这样，一点也不奇怪了。后来高考，她只能读专科，还是不好的专科，还想复读，后来还是去了，又想退学啥的，父母能让她折腾的机会不多了，我也不会对她说什么，反正我即使能读一本，现在无房无车，还是垃圾。现在她读专科，看她还能不能腆着大脸说别人垃圾。我12岁才和他们生活，父母对我的影响比较小。童年也比小的兄妹要艰苦一点，因此，就非常渴望读书，读书也还算努力，曾经立志做孙逸仙那样的人。小时候的玩伴都在初中或者小学辍学了，而我侥幸能上完大学。大学后发现孙逸仙真特么不好当，放弃幻想，做一个咸鱼算了。 总结 今年总体比较满意。以后继续加强学习，要出去多走走，练习一下摄影。然后继续了解中医，希望更多的人能来关注和了解中医和现代医学，不会被中医的阴阳虚实，正气淫气忽悠住。]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴阳五行之来历]]></title>
    <url>%2F2020%2F01%2F18%2F%E9%98%B4%E9%98%B3%E4%BA%94%E8%A1%8C%E4%B9%8B%E6%9D%A5%E5%8E%86%2F</url>
    <content type="text"><![CDATA[因为谭秦东被鸿茅药酒“跨省抓捕”事件，开始注意到中药，然后了解到中医，才发现中医的荒谬。这篇文章是梁启超1921年批判阴阳五行的，然作为中医的基本理论，有必要了解它的来历。我在360图书馆找到，梁启超：阴阳五行说之来历, 识图软件扫描提取文字，批注一些生涩的词语，可能有误，欢迎指正。格式可能乱了，百度网盘获取原文 提取码：wpf6 阴阳二字语意之变迁 五行二字语意之变迁 阴阳家之成立及阴阳五行说之传播 阴阳五行说之来历[1] ​ 阴阳五行说，为二千年来迷信之大本营，直至今日，在社会上犹有莫大势力今当辞而辟之，故考其来历如次。 阴阳二字语意之变迁 ​ 阴阳两字义之见于《说文》者，《阜部》云：“陰，阖也。水之南，山之北也。从月，侌[2]声。”，“陽，高明也。从日，昜声。“ ，然阜（fù）旁[3]乃孳乳后起[4]，其原字实为侌昜。《雲部》云：“黔，云覆日也。从雲，今声。侌，古文。”《勿部》云：“昜，开也。从日、一、勿。一曰飞扬，一曰长也，一曰疆者众兒。” 侌字所从之 “云”，即古雲字，侌为云覆日，此其本义。引申为凡覆蔽之义。覆蔽必阖，因又引申为阖义。背日之地必阖，城市多倚北而背日，因又引申为背面、或里面、或北方之义。此 “陰” 字 字义变迁之大凡也。昜，从日从一者，日在地上，即日出之意。从勿者，《说文》云：“勿，州里所建旗象。……” 日出地上而建旗焉，气象极发扬，此其本义。引申以表日之光彩，故日称太阳，朝日称朝阳，夕日称夕阳。日出则暖，故又引申谓和暖之气为阳气。向日乃能见阳光，故又引申为正面、或表面、或南方之义。此 ”陽“ 字字义变迁之大凡也。南北向背相对待，故阴阳二字连用，常以表南北或表里外[5]之义。 ​ 阴阳两字相连属成一名辞，表示无形无象之两种对待的性质，盖自孔子或老子始。孔、老以前之书确实可信者，一日《诗经》，二曰《书经》，三日《仪礼》，四曰《易经》之卦辞爻辞[6]。《仪礼》全书中无阴阳二字，可置勿论。其他三经所有阴字、阳字之文句及意义，列举诠释如下： 《诗经》 “其阴，虺虺[7]其雷。”（《卫风·终风） “习习谷风，以阴以雨。”（《卫风·谷风》） “阴续。”（《秦风·小》） “黍苗，阴雨之”（《曹风·下泉》） “迨天之未阴雨”（《豳风·鸦》） “二之日，纳于凌阴。”（豳风·七月》） “又窘阴雨。”（《小雅·正月》） “既之阴女，反我赫”（大雅·桑柔）） “其雷，在南山之阳。”《《周南·殷其需》 “君子阳阳，左执簧，右招我由房。”（《王风·君子扬扬》） “我送舅氏，曰至渭阳。”《秦风·渭阳》） “春日载阳。”（《豳风·七月》） “载立载黄，我朱孔阳。”（同上） “湛湛露斯，匪阳不晞。”（《小雅·湛露》） “日归归，岁亦阳止。”（《小雅·采薇》） “日月阳止，女心伤止。”（《小雅·杕杜》） “在洽之阳。”（《大雅·大明》） “居岐之阳。”（《大雅·皇矣》） “度其夕阳，豳居允荒。”（《大雅·公刘》） “桐梧生矣，于彼朝阳。”（《大雅·卷阿》） “龙阳阳。”（《周颂·载见》） “居岐之阳。”（《鲁颂·宫》 “既景乃冈，相其阴阳。”（《大雅·公刘》 《书经》： “阳鸟攸居。”（《禹贡》） “华阳黑水惟梁州。”（同上） “岷山之阳。”（同上） “南至于华阴。”（同上） “惟天阴下民。”（《洪范》） “乃或亮阴，三年不言。”（《无逸》） 《易》[8]爻辞： “鹤鸣在阴，其子和之。”（《中孚》九二） 右[^9]《诗经》言阴者八，阳者十四，言阴阳者一。《书经）言阴言阳各三。最奇者《易经》一书，庄子所谓 “《易》以道阴阳“ 者，卦辞爻辞中，仅有此“中孚[^10]九二[^11]之一条，单举一阴字。 右列诸文中阴字，《谷风》、《下泉》、《鸱》、《正月》之 “阴雨“ 及《终风》之 ”瞪瞪其阴“，皆用“云覆日”之义，即最初本义也《桑柔》之“既之阴女”，孔疏云：“往阴覆汝”。《洪范》之 “惟天阴骘（zhì）[^12]下民”，马注云：“阴，覆也。“ 皆用覆蔽之引申义。“阴靷鋈（wù）续”，《毛诗》云：“阴靷（yǐn），掩轨也。” 掩亦覆义。《无逸》之 “亮阴”,《尚书大传》作 “梁阖”，言凶庐之阖也，即《说文》以释阴之义。《七月）之“纳于凌阴”，《毛诗》云：”凌阴，冰室也。”，盖深邃黑暗之室。《中孚》之 “鹤鸣在阴”，谓鹤鸣于其子所不及见之处，而其子能和之也，亦覆蔽之引申义。《禹》之“华阴”，谓华山之背面，亦从阖覆义引申来。凡三经所有阴字，意义尽于此。 ​ 其阳字，《闷官》之“龙族阳阳”，正昜字从勿之本义，谓在日下飞扬也。“君子阳阳[9]” 者，《史记·晏子传》：“意气阳阳甚自得”。亦如日下旗，神气飞扬也。此皆最初之义，《湛露》之“匪阳不晞”，《卷阿》之 “于彼朝阳”，《公刘》之“度其夕阳”，皆节彼日在地上之义，直以阳为日。《七月》之“我朱孔阳”，言朱色之光如日，亦同前解。《七月》之“春日载阳”，《采薇》之”岁亦阳止”，《杜》之“日月阳止”，《禹贡》之 “阳鸟攸居”，皆用向日和暖之引申义。《殷其雷》之“南山之阳”，《渭阳》之“曰至渭阳”，《大明》之“在洽之阳”，《皇矣》，《闷官》之 “居岐之阳”，《禹贡》之“华阳”、“岷山之阳”，皆言某山某水之正面、或表面、或南方，盖从向日之一面得名也。凡三经所有阳字，意义尽于此。 ​ 阴阳二字连用者，惟《公刘》“既景乃冈，相其阴阳” 一语，谓在山冈上测日影，察其向背云尔，与后世所谓阴阳之义迥别。 ​ 由此观之，**商周以前所谓阴阳者，不过自然界中一种粗浅微末之现象，绝不含有何等深邃之意义。**阴阳二字意义之剧变，盖自老子始。老子曰：“万物负阴而抱阳。”[10] 此语当作何解，未易断言[11]，抑[12]固有以异于古所云矣。虽然，五千言中言阴阳者只此一句，且亦非书中重要语。故谓老子与阴阳说有何等关系，吾未敢承。 ​ 庄子言“《易》以道阴阳”，《易》卦辞、爻辞皆未尝言阴阳，既如前述。然则此语只能作孔子所赞之《易》解耳。今所传《十翼》，其确出孔子手著最可信者，莫如《彖传》、《象传》，然此两传中，惟《乾》初九《象传》云：“潜龙勿用，阳在下也。”《坤》初六《象传》云：“履霜坚冰，阴始凝也。”《彖》、《象》两传中，刚柔、内外、上下、大小等对待名词，几于[13]无卦不有，独阴阳二字仅于此两卦各一见，可谓大奇。至《系辞》、《说卦》、《文言》诸传，则言之较多。今列举其文如下： ​ “一阴一阳之谓道。” ​ “阳卦多阴，阴卦多阳。其故何也？阳卦奇，阴卦偶。” ​ “乾，阳物也；坤，阴物也。阴阳合德，而刚柔有体。” ​ “阴阳之义配日月，易简之善配至德。”（以上《系辞传》） ​ “观变于阴阳而立卦。” ​ “立天之道，曰阴与阳。立地之道，曰柔与刚。立人之道，曰仁与义。”（以上《说卦传》） ​ “潜龙勿用，阳气潜藏。” ​ “阴虽有美含之。” ​ “阴疑于阳必战，为其嫌于无阳也，故称龙焉。”（以上《文言传》） ​ 《系辞》、《文言》诸传，不敢遂认为直接出孔子手。因传中多有“子曰”字样，论体例应为七十子后学者所记也。姑置不论，即将以上诸条全认为孔子学说，其所谓阴阳者亦不过如此。盖孔子之哲学，谓宇宙间有两种力相对待，相摩荡，如电气之有正负，斯为万有之缘起。此两种力难于表示，故以种种对待名辞形容之，如刚柔、动静、消息、屈伸、往来、进退、翕辟[14]等皆是，而阴阳亦其一也。就中言阴阳者，远不如言刚柔、消息、往来者之多。与其谓《易》以道阴阳，母宁[15]谓《易》以道刚柔，道消息也。**要之阴阳两字，不过孔子“二元哲学”之一种符号，而其所用符号，又并不止此一种，其中并不含有何等神秘意味，与矫诬[16]之术数更相远。**故谓后世之阴阳说导源于孔子，吾亦未敢承[17]。 五行二字语意之变迁 五行二字最初见于经典者，则《尚书·甘誓》，云：“有扈氏威侮五行，怠弃三正。”[^22]此语作何解，颇难臆断。后世注家，多指五行为金、木、水、火、土，三正为建子、建丑、建寅。然据彼辈所信，子、丑、寅建，分配周、商、夏。《甘誓》为夏书，则时无子、丑二建，何得云三正？且金、木、水、火、土之五行，何得言威侮，又何从而威侮者？窃疑此文应解为威侮五种应行之道[^23]，怠弃三种正义。其何者为五，何者为三，固无可考。然与后世五行说绝不相蒙，盖无疑。 ​ 次则为《洪范》。自汉人作《洪范五行传》后，于是言五行者必联想《洪范》，此两名词几成不可离之关系。虽然，实际上《洪范》所谓五行果有何等神秘意味否耶？请勘视原文： ​ “我闻在昔，鲧（gǔn）堙（yīn）洪水，汩陈其五行。” ​ “一五行：一曰水，二曰火，三曰木，四曰金，五曰土。水曰润下，火曰炎上，木曰曲直，金曰从革，土爱稼稿。润下作咸，炎上作苦，曲直作酸，从革作辛，稼作甘。“[18] ​ 此不过将物质区分为五类，言其功用及性质耳，何尝有丝毫哲学的或术数的意味？ &quot; 鲧湮洪水，汩陈其五行 ” 者，言因湮水之故，致一切物质不能供人用。若谓汩乱五行原理，则与堙水何关耶？《洪范》本为政治书，其九畴先列五行者，因其为物质的要素，人与经济所攸命耳。《左传》所谓 **“天生五材，民并用之”，即此义也。然则《洪范》本意，并非以此一畴统贯生八畴甚明，后世愚儒，欲取凡百事物皆纳入五行中，于是首将第二畴之五事貌、言、视、听、思分配水、火、木、金、土。**试问，第四畴之五纪，第九畴之五福，数固同为五，然有法分配否？ 第三畴之八政，第六畴之三德，数不止五，或不及五者，又有法分配否？ 第五畴之皇极，第七畴之稽疑，第八畴之庶，并无数目者，又有法分配否？以一贯八，而所贯者亦仅一而止。愚儒之心劳日拙，大可怜也。 ​ 除《书经》此两文外，《诗经》、《仪礼》、《易》经传乃至《老子》、《论语》、《孟子》皆不见有以五行二字连文者。（此凭吾记忆所及耳，读者如有所发见望指正） 惟《墨子·经下》及《经说下》云：“五行毋常胜，说在宜。” “五合，水火土，火离然。火烁金，火多也。金靡炭，金多也。合之府水，木离木。……” 此确与《洪范》所言五行为同物，且其言“无常胜”之义，注家或以后世五行生说解之。实则胜训贵，意谓此五种物质无常贵，但适宜应需则为贵，其说甚平实，不待穿凿也。 ​ 《荀子·非十二子篇》，其非子思、孟轲也，有颇奇异之数语。曰：“案往旧造说，谓之五行，甚僻违而无类，幽隐而无说，闭约而无解。案饰其辞而衹敬之，曰：此真先君子之言也。子思唱之，孟轲和之。” ​ 此五行不知作何解，若谓即《洪范》之五行耶？子思、孟轲书中只字未尝道及。《中庸》以君臣、父子、兄弟、夫妇、朋友五者为天下之达道，道有行义，五行或指此耶？然此为儒家常言，非思、轲所创，且无所谓“僻违、幽隐、闭约”。杨倞注释为仁、义、礼、智、信之五常[19]，或者近是然子思说虽无可考，或《中庸》外尚有著述。孟子则恒言仁义礼智，未尝以信与之并列也。此文何指，姑勿深论但决非如后世之五行说，则可断言耳。 ​ 古籍中可信者，其言五行之说，以吾记忆所及，尽于是矣。此外，尚有应怀疑者一段，则《左传》昭二十五年记郑子大叔与晋赵简子问答语： ​ “吉也闻诸先大夫子产日：天地之经，而民实则之…用其五行气为五味，发为五色，章为五声。……”[20] ​ 此与后世所谓“《洪范》五行”者甚相类。此文如可信，则是孔子之先辈子产时已有此说矣。然《左传》真伪，在学界久成问题，藉日非全伪，然其作者最早应为战国时人，且最少有一部分为汉人窜乱，此殆无可讳者。谓子产有是言，吾以当时所有学说旁证之，不能置信也。 ​ 五行说之极怪诞而有组织者，始见于《吕氏春秋》之十二览。其后《小戴礼记》采之，即《月令篇），《淮南子》又采之，其说略如下： ​ “孟春之月……其日甲乙，其帝太皞，其神句芒，其虫鳞，其音角……其味酸，其臭，其祀户，祭先脾。……天子居青阳左个，驾苍龙，载青旂，衣青衣，服青玉，食麦与羊。……“ ​ 如此将一年四季分配五行：春木、夏火、秋金，冬水，所余之土无可归，则于夏秋交界时为拓一位置。于是五方之东、西、、北、中，五色之青、赤、黄、白、黑，五声之宫、商、角、、羽，五味之酸、苦、咸、甘，五虫之毛、介、鳞、羽、倮，五祀之井、灶、行，户、中，五谷之黍、稷、稻、麦、，五畜之马、牛、羊、犬、豕，五脏之心、肝、肺、脾、肾，五帝之太皞（hào）、炎帝、黄帝、少昊、颛顼，五神之句芒、祝融、后上、蓐收、玄冥，皆一一如法分配。《洪范》五事抑未编入。乃至如十天、六律、六吕等数目不与五符者，亦割裂以隶[21]之。如是将宇宙间无量无数之物象事理[22]，皆硬分为五类，而以纳诸所谓五行者之中，此种诡异之组织遂[23]二千年蟠据全国人之心理，且支配全国人之行事。嘻！吾辈死生关系之医药，皆此种观念之产物，吾辈最爱敬之中华民国国旗，实为此种观念最显著之表象，他更何论也。 阴阳家之成立及阴阳五行说之传播 ​ 由此观之，春秋战国以前，所谓阴阳，所谓五行，其语甚希见，其义极平淡，且此二事从未尝并为一谈。 请经及孔、老、墨、孟、韩诸大哲皆未尝齿及。 然则造此邪说以惑世诬民者谁耶？其始起于燕、齐方士[24]。而其建设之，传播之，宜负罪责者三人焉：日邹衍，曰董仲舒，曰刘向。 ​ 《史记·孟子荀卿列传》云：“邹衍乃深观阴阳消息而作迁怪之变，《终始》、《大圣》之篇十余万言。” 又云：“ 称引天地剖判以来，五德转移，治各有宜，而符应若兹。” 又《封禅书》云：“齐威、宣之时，驺子[25]之徒，论著终始五德之运，及秦帝，齐人奏[26]之。” 《文选·魏都赋》注引《七略》云：“邹子有终始五德，从所不胜，土德后木德继之，金德次之，火德次之，水德次之。” 邹衍之书，见于《汉书·艺文志》者，有《邹子》四十九篇、《邹子终始》五十六篇，今虽已佚，然据《史记》及《七略》所说，可知其概。妖言之作俑者，实此人也。 ​ **衍倡此妖言，乘秦、汉间学术颓废之隙，遂以万斛[27]狂澜之势，横领思想界之全部。**司马谈[28]作《六家要旨》，以阴阳家与儒、道、墨、名、法并列，其势力可想。今将《汉书·艺文志》所著录此类书，照录如下：书目下括中文字皆《汉书》原注： 《宋司星子韦》三篇（景公之史） 《公生终始》十四篇（传邹爽终始书） 《公孙发》二十二篇（六国时） 《子》四十九篇（名衍，齐人，为燕昭王师居稷下，号“谈天衍”）《邹子终始》五十六篇 《乘丘子》五篇（六国时） 《杜文公》五篇（六国时） 《黄帝秦素》二十篇（六国时，韩请公子所作） 《南公》三十一篇（六国时） 《容成子》十四篇 《张苍》十六篇（承相北平侯） 《邹爽子》十二篇（齐人，号曰“雕龙爽”） 《间丘子》十三篇（名快，魏人，在南公前） 《冯促》十三篇（郑人） 《将巨子》五（六国时，先南公，南公称之） 《五曹官制》五篇（汉制，似贾谊所条） 《周伯》十一篇（齐人，六国时） 《卫侯官》十二篇（近世，不知作者） 《于长天下忠臣）九篇（平阴人，近世） 《公孙浑邪》十五篇（平） 《阴阳》三十八篇（不知作者） 《公孙浑邪》十五（平曲侯） 《杂阴阳》三十八篇（不知作者） 右《诸子略》阴阳家二十一家三百大十九篇 《大壹兵法》一篇[29] 《天一兵法》三十五篇 《神农兵法》一篇 《黄帝》十六篇（图三卷） 《封胡》五篇（黄帝臣，依讬也） 《风后》十三篇（图二卷黄帝臣，依讬也） 《力牧》十五篇（黄帝臣，依讬也） 《冶子》一篇（图一卷） 《鬼容区》三篇（图一卷，黄帝臣，依讬也） 《地典》六篇 《孟子》一篇 《东父》三十一篇 《师旷》八篇（晋平公臣） 《弘》十五篇（周史） 《别成子望军气》六篇（图三卷） 《辟兵威胜方》七十篇 右《兵书略》阴阳家十六家二百四十九篇《泰一阴阳》二十三卷 《黄帝阴阳》二十五卷 《诸王子论阴阳》二十五卷 《大元阴阳》二十六卷 《三典阴阳谈论》二十七卷 《神农大幽五行》二十七卷 《四时五行经》二十六卷 《猛子昭》二十五卷 《阴阳五行时令》十九卷 《堪舆金》四卷 《务成子灾异应》十四卷 《十二典灾异应》十二卷 《钟律灾异》二十六卷 《钟律丛辰日苑》二十三卷 《钟律消息》二十九卷 《黄钟》七卷 《天一》六卷 《泰一》二十九卷 《刑德》七卷 《风鼓六甲》二十四卷 《风后孤虚》二十卷 《六合随典》二十五卷 《转位十二神》二十五卷 《羡门式法》二十卷 《门式》二十卷 《文解六甲》十八卷 《文解二十八宿》二十八卷 《五音奇腋用兵》二十三卷 《五音奇胲刑德》二十一卷 《五音定名》十五卷 右《数术略）五行家三十一家六百五十二卷 【上面所列的总结】 ​ 此外，如《数术略》医经、房中[30]两门，亦大抵属此类，观今所传《黄帝内经》可知也。即以此三门论，为书一千三百余篇，对于《艺文志》总数万三千二百六十九卷，已占十分一而强。其实细绎全志目录，揣度其与此等书同性质者，恐占四分之一乃至三分之一。嘻！学术界之耻辱，莫此为甚矣。 ​ 邹衍书及他诸书皆不可见，可见者有董仲舒之《春秋繁露》，仲舒二千年来受醇儒之徽号[31]，然其书祖述[32]阴阳家言者几居半。今无暇一一胪列内容，但举其篇目： 《五行对》第三十八 《五行之义》第四十二 《阴尊阳卑》第四十三 《王道通三》第四十四 《天辨在人》第四十六 《阴阳位》第四十七 《阴阳终始》第四十八 《阴阳义》第四十九 《阴阳出入》第五十 《天道无二》第五十 《暖敦多》第五十二 《基义》第五十三 《同类相动》第五十七 《五行相胜》第五十九 《五行逆顺》第六十 《治水五行》第六十一 《治乱五行》第六十二 《五行变救》第六十三 《五行五事》第六十四 《天地之行》第七十八 《如天之为》第八十 《天地阴阳》第八十一 ​ 以上二十三篇，皆言阴阳五行，殆占全书之半。其中，所含精深之哲理固甚多，要之半袭阴阳家言，最少亦受其影响，而绝非孔、孟、荀以来之学术，则可断言也。**仲舒以儒家大师，而态度如此，故一时经学家皆从风而靡。**仲舒自以此术治《春秋》，京房、焦赣之徒以此术治《易》，夏侯胜、李寻之徒以此术治《书》，翼奉、孟之徒以此术治《诗》，王史氏之徒以此术治《礼》。于是庄严纯洁之六经被邹衍余毒所蹂躏，无复完肤矣。《艺文志·六艺略》所著录之书，其属于此类者以吾所推度，最少有如下之各种： 《易》： 《古五子》十八篇（自甲子至壬子说《易》阴阳） 《淮南道训》二篇（淮南王安聘明《易》者九人，号九师说）《杂灾异》三十五篇 《神输》五篇（师古曰，刘向《别录》云，神输者，王道失则灾害生得则四海输之祥瑞） 《孟氏京房》十一篇 《灾异孟氏京房》六十六篇 《京氏段嘉》十二篇 《书》： 刘向《五行传记》十一卷 许商《五行传记》一卷 《诗》： 《齐后氏传》三十九卷 《齐孙氏传》二十八卷 《齐杂记》十八卷 《礼》： 《明堂阴阳》三十三篇 《王史氏》二十一篇（？） 《明堂阴阳说》五篇 《古封群祀》二十二篇 《封禅议对》十九篇 《汉封样群祀》三十六篇 《春秋》： 《公羊外传》五十篇（？） 《谷梁外传》二十篇（？） 《公羊杂记》八十三篇（？） 《诸子略》儒家 《董仲舒》百二十三篇（？） ​ 右诸书虽什九[33]已佚，然经近人辑出，尚多能得其梗概。要之，两汉所谓今文家经说，其能脱阴阳五行臭味者，什无二三，大率自仲舒启之。 ​ 《汉书·五行志》云：“汉兴，承秦灭学之后，景武之世，董仲舒治《公羊春秋》，始推阴阳，为儒者宗。宣、元之世，刘向治《谷梁春秋》，数其祸福，傅以《洪范》，与仲舒错[34]。至向子歆，……言《五行传》，又颇不同。是以揽仲舒、别向、歆……所陈行事，……著于篇。” 据此知汉儒阴阳五行之学，开于仲舒而成于向、歆父子。《五行志》所载，大抵即刘向《洪范·五行传》之言也。吾侪试一籀[35]读，当审其内容为何如。而后此所谓正史者，大率皆列此一篇，千余年莫之易呜呼！ 禨[36]祥灾之迷信，深中于士大夫，智日以昏，而志日以偷，谁之咎也。吾故略疏证其来历如右，俾诵法[37]孔子之君子得省览焉。 说明：梁启超写于1921年，由知 乎用户Jack Lei 校对，批注。 ↩︎ 侌：yīn，古同阴。 ↩︎ 阜旁：耳朵旁。 ↩︎ 孳乳后起：派生而来。 ↩︎ 外：原文没有外，认为作者笔误。 ↩︎ 卦辞爻辞：卦辞，说明《易经》六十四卦要义的文字，即占卜是解释卦象的文字。爻（yaó）辞，占卜时用以解释爻的文字，一卦有六爻。阳爻称之为九，阴爻称为六。从上到下，初九（六），九二（六二），九三（六三），九四（六四），九五（六五），上九（上六）。 ↩︎ 虺虺：拼音（huǐ huǐ ） , 表雷声。 ↩︎ 《易》：《易经》的简称，下同。 ↩︎ 阳阳：今作“扬扬”。 ↩︎ 中医因此说中医起源于道。 ↩︎ 断言:可以肯定地说。 ↩︎ 抑：语气词，在句首，无义。 ↩︎ 几于：几乎。 ↩︎ 翕辟：开合。 ↩︎ 母宁：毋宁，作者笔误。 ↩︎ 矫诬：故弄玄虚。 ↩︎ 承：奉也，受也，接受。 ↩︎ 五味：五行配五味出现了。 ↩︎ 五常：五常配五行，有别于儒家的五德。 ↩︎ 五声：五声配五行。 ↩︎ 隶：通 “离”，动词，使之离，离开，废弃之意。 ↩︎ 物象事理：事物的现象，事物的原理，指自然运行的原理。 ↩︎ 遂：竟然。 ↩︎ 方士：术士，修习方术的人，包括占卜、预言、法术、气功、炼丹等，达到趋吉避凶、通灵、长生不老、羽化飞升等目的。 ↩︎ 驺子：邹衍的尊称。 ↩︎ 奏：奉上，上奏。 ↩︎ 万斛（hú）: 容量之多。斛，体积单位，十斗或五斗为一斛。 ↩︎ 司马谈：司马迁的父亲。 ↩︎ 上面所列的总结，下同。 ↩︎ 房中：房中术，包括优学、性学和性保健，御女之术，多由男性对女性实施。女性对男性实施的，又叫媚术。 ↩︎ 醇儒之徽号：醇儒，纯在的儒生。徽号，尊号。 ↩︎ 祖述：效法前人。 ↩︎ 什九：十之九。 ↩︎ 错：打磨。 ↩︎ 籀（zhòu）：读书。 ↩︎ 禨（jī）：迷信鬼神，向鬼神求福。 ↩︎ 诵法：称颂并效法。 ↩︎]]></content>
      <categories>
        <category>中医</category>
      </categories>
      <tags>
        <tag>中医</tag>
        <tag>阴阳五行</tag>
        <tag>伪科学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows7下的包管理器Chocolatey的安装及使用]]></title>
    <url>%2F2019%2F10%2F07%2FWindows7%E4%B8%8B%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8Chocolatey%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[以前安装过 chocolatey，win7 下报错，试了几次都没成功，今天学习 electron，又安装了一次，居然成功了。记录一下安装和使用。 安装 使用 使用 gui 其他用法 参考 安装 win7 终端下，或者cmder下，输入下面的字符串，然后回车: 1@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin" 没有错就显示安装信息了，安装成功后可能会报警告，别管它，然后检查是否安装成功： 在 git bash 或者 cmder 输入： 1choco 显示版本号等信息，就表示安装成功了。 使用 choco -h 可查看常用命令，这里记录常用的命令： 123456789101112131415161718192021choco &lt;command&gt; -h # 查看命令帮助 choco list -h 查看 list 用法choco list &lt;filter&gt; # 搜索本地或者远程的安装包 clist 简写 search / find 和 list 功能相同choco list -li # 查看本地安装的软件choco list -lo # 列出已安装choco list --local # 查看本地通过 choco 安装的软件choco info &lt;pkg&gt; # 查看安装包信息choco install &lt;pkg1&gt; &lt;pkg2&gt; # 安装choco install --yes &lt;pkg1&gt; &lt;pkg2&gt; # 安装时无需确认choco install &lt;pkg&gt; -y # 同上cinst &lt;pkg&gt; -y --dir DIR # 指定 DIR 为安装路径cinst &lt;pkg&gt; --version n #指定版本号安装choco uninstall &lt;pkg&gt; # 卸载软件cuninst &lt;pkg&gt; # 卸载choco outdated # 查看可更新的软件# 更新choco upgrade &lt;pkg|all&gt; [&lt;pkg&gt;] # 更新所有或多个软件cup &lt;pkg|all&gt; [&lt;pkg&gt;] # 更新所有或多个软件cup &lt;pkg&gt; --version 1.0.0 # 更新某个版本 使用 gui 使用命令不习惯，还可以使用 gui。 1cinst chocolateygui -y # 安装 在所有程序里搜索choco ，点击启动gui了。 还可在 chocolatey商店 查找软件。 其他用法 修改安装的默认路径： 花钱使用高级版本； 修改注册表，谨慎操作，修改了，可能会导致某些软件运行报错，比如firefox。 参考 Windows7下的包管理器Chocolatey的安装 Window上更方便的软件安装方式 — Chocolatey Chocolatey软体管理神器 设置软件默认安装路径（一劳永逸）]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>数码产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo + github搭建个人主页]]></title>
    <url>%2F2019%2F10%2F06%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[大学时搭建过 github 博客，但是后来没怎么弄了。感觉有点折腾，就没有继续维护了，今天再来重新搭建一个博客。本文记录搭建操作。 预备知识： 安装 hexo 创建托管博客的仓库 部署本地博客到 gitbub 创建文章 给 markdown 文章加入图片 高级主题[^说明] 渲染文章目录(TOC) 增加评论功能 增加访客统计 增加 stackoverflow 技术媒体 增加版权声明 增加推荐阅读 写在最后 预备知识： npm 命令； git 命令 github 常见操作 环境要求： node git 我的环境： 123456$ git versiongit version 2.15.1.windows.2$ node -vv8.11.1$ npm -v6.4.0 安装 hexo 1npm i -g hexo-cli 在某个文件夹内初始化 hexo 博客所需要的文件 123mkdir myBlog # /e/HexoPages 新建一个文件夹cd myBloghexo init # 初始化一个hexo博客需要的资源 得到如下目录： 1234567├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 1npm i # 安装 npm 依赖 本地预览博客： 1hexo s 打开http://localhost:4000即可看到效果。 创建托管博客的仓库 仓库名字必须用用户名.github.io，需要公开。 部署本地博客到 gitbub 修改_config.yml 打开 _config.yml ，将 deploy 修改如下注意空格 12345deploy: type: git # 版本管理工具 repo: # 仓库信息 github: https://github.com/JackZhouMine/jackzhoumine.github.io branch: master # 使用分支 其他配置也可以修改，比如我将站点信息修改如下： 12345678# Sitetitle:jackzhouminesubtitle:description:keywords:author: jackzhouminelanguage:timezone: 安装 hexo-deployer-git 1npm i -S hexo-deployer-git 部署 1hexo d -g 打开我的主页链接 https://jackzhoumine.github.io，看到页面就部署成功了。 创建文章 创建文章 执行hexo new '文章标题'，会在source/_posts文件夹内新建一个md文件，就可在里面写文章了，当然也可以手动创建。 hexo new 简写成 hexo n。 预览效果 创建完成，执行以下命令,在本地预览效果： 1234hexo ghexo s# 或者 hexo s g 1hexo S --draft # 预览草稿 创建草稿 可先创建草稿，想发布时，在发布。 12hexo new draft "文章标题" # 会在 /source/-drafts 里生成草稿hexo publish filename # 将草稿发布成文章，会进入 post 目录 如何批量发布呢？ 部署到线上 1234# 非必需hexo clean # 清除缓存文件（db.json）和静态文件。更改后不生效，就需要运行该命令。# 部署hexo d g # 部署到线上 更新已发布的文章 最简单的是修改完文章后，再部署一次。 文章加上更新时间，可在主题里配置。 我使用更加粗暴的方法，每次更新文章，就使用 vs code 扩展 Insert Date String 插入当前时间。 给 markdown 文章加入图片 使用本地图片，markdown 笔记移动后，图片路径失效，免费的图床可能到倒闭，毕竟都是小公司。解决办法是将所有图片在一个git仓库里管理起来，托管在 github （没有巨硬这个财大气粗的土豪做后台，也倒不了）上，安全放心。 需要用到图片时，打开图片，然后在代码块左上方点 Download 按钮，打开的新标签里只有图片了，复制地址栏图片链接，类似https://raw.githubusercontent.com/xxxx到文章里，就可放心饮用了。 高级主题[^说明] 可以为博客增加评论功能，方便与他人交流。增加访客统计等。 渲染文章目录(TOC) hexo 默认的渲染模块，不支持渲染TOC的，可使用hexo-renderer-markdown-it-plus实现渲染 TOC。 安装 12npm un hexo-renderer-marked # 卸载原来的渲染模块npm i hexo-renderer-markdown-it-plus -S 修改配置 在配置文件中加入以下选项： 1234567891011## 渲染 TOCmarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight 还可以看模块文档，配置其他高级选项。 写文章 只写 TOC，是不会渲染目录的，需要加上@,并且不会渲染一级标题。推荐在摘要后面写目录，并用横线分隔摘要。 1234&lt;!--more--&gt;***@[TOC] 增加评论功能 yilia 主题配置开启就可。 疑问：为何disqus评论底部会显示其他博客的评论内容呢？ 增加访客统计 使用不蒜子统计功能，免费好用。 打开 themes/yilia/layout/_partial/footer.ejs， 在id为footer-info的div后面增加以下内容： 12345678&lt;div calss=&quot;count-span&quot;&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;| &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 总访客: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 在footer顶部增加统计脚本： 1&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 部署即可看到效果了，可增加一些好看的样式。 增加 stackoverflow 技术媒体 yilia 主题没有引入 stackoverflow ,可执行增加。 Acfun已经凉了，在 themes\yilia\source\main.0cf68a.css中搜索acfun，替换成stackoverflow，图标就不换了。 增加版权声明 比较简单，参考 增加推荐阅读 推荐阅读是通过插件 hexo-recommended-posts 来实现的, 它不仅可以推荐你自己的博客, 还可以推荐别人的相关博客. 如果有比较多人使用这个插件的话, 不仅能帮读者快速找到感兴趣的内容, 同时也能增加自己博客的流量。 在 post 中增加 recommended-post.ejs 1234567891011121314151617&lt;% if(theme.recommended_posts.enable &amp;&amp; !index) &#123;%&gt; &lt;div class=&quot;recommended_posts&quot;&gt; &lt;h3&gt;推荐阅读&lt;/h3&gt; &lt;ul&gt; &lt;% let post_list = recommended_posts(page, site) %&gt; &lt;% for (let i in post_list)&#123;%&gt; &lt;li&gt; &lt;a href=&quot;&lt;%= post_list[i].permalink %&gt;&quot; title=&quot;&lt;%= post_list[i].title %&gt;&quot; target=&apos;_blank&apos;&gt; &lt;%- post_list[i].title %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/div&gt;&lt;%&#125;else&#123;%&gt; &lt;div class=&quot;recommended_posts&quot; hidden&gt;&lt;/div&gt;&lt;%&#125;%&gt; 在 _patial 中增加样式 recommended-post.styl 12345678.recommended_posts padding: 0.5em 1em; border-left: 3px solid #6f42c1; background-color: #efefef; li &#123; margin: 5px 0; &#125; a:link &#123; color: blue; &#125; a:hover &#123; text-decoration:underline;color: red&#125; a:visited &#123; color: green; &#125; 在style.styl和article.ejs中引入样式和ejs @import &quot;_partial/recommended-post&quot; 引入的 ejs 放在评论上边。 增加配置项 在主题的配置中增加： 123# 推荐阅读 需要 hexo-recommended-posts 支持recommended_posts: enable: true # 启用文章推荐 在博客配置增加： 123# 推荐阅读 需要 hexo-recommended-posts 支持recommended_posts: autoDisplay: false #设置为 fasle，不采用默认样式 安装 hexo-recommended-posts 1npm i -S hexo-recommended-posts 预览效果 1hexo recommend &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 参考：为 hexo maupassant 主题添加文章版权信息和推荐阅读功能 写在最后 发现一些网站，专门爬取别人写的文章，也不注明出处，该今后发表文章，都增加不限于打赏码、微信公众号等信息。 [^说明]：使用ocean主题，yilia 主题设置就删除了。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 学习笔记]]></title>
    <url>%2F2019%2F10%2F06%2Fgit-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Git是一个分布式版本控制系统（CVS），可以记录文本文件的变化（修改、增加、删除等操作），比如 TXT、HTML、程序源代码等，不能记录其他文件（图片、音频等二进制文件）的变化，不能记录word文档的变化。 Git常见操作 配置相关 查看配置 添加配置 删除配置 编辑配置文件 创建新仓库 克隆已有仓库 添加更改 重命名已跟踪的文件 撤销修改 从暂存区撤回 commit 相关操作 提交更改到仓库 合并 commit 修改比较 git diff 版本回退 查看提交记录 版本回退 工作区和暂存区 status 和 diff 比较的是哪些？ diff 的比较 工作区和暂存区的比较 暂存区和 HEAD 比较 工作区和 HEAD 比较 分支比较 输出比较结果 status 的比较 撤销修改 删除文件 远程仓库 关联远程仓库 查看远程仓库 删除本地分支和远程分支的关联 推送本地修改到远程仓库 分支合并 合并分支方法一（推荐） 合并分支方法二 分支合并方法三 强制覆盖合并 如何避免每次输入密码? 查看分支 新建分支 删除本地分支 删除远程分支 重命名分支 已跟踪的文件取消跟踪 删除已跟踪的文件 .gitignore 文件相关 忽略规则 常见的规则模式 其他忽略方式 常见项目的 .gitignore 文件 列出忽略的文件 删除忽略文件 列出被跟踪的文件 常见问题 本地仓库版本落后于远程仓库版本 Git推送提示：remote origin already exists todo git 进阶 Git常见操作 配置相关 配置分为系统配置、全局配置和仓库配置，全局配置一般对该电脑的使用这都是有效的，也就对所有仓库有效了，仓库配置只对某个仓库有效。命令加--global是全局配置。 查看配置 12git config --global -l # 全局配置git config --local -l # 仓库配置 添加配置 1git config --global --add &lt;key&gt; value 删除配置 1git config --global --unset &lt;key&gt; # 删除全局 key 配置 编辑配置文件 1git config --global -e # -e 是 --edit 的别名，会在编辑器中打开配置文件。编辑后配置，配置就生效了。 ###创建版本仓库 创建新仓库 12345# 在某个文件下，该文件夹成为一个 git 仓库，生成一个 .git 文件夹git initgit init &lt;fileName&gt; # 将 fileName 初始化为一个 git 仓库# 帮助命令git help &lt;command&gt; 12$ ls -a./ ../ .git/ .git 文件夹内的内容不可轻易改动，里面记录了文件变化 克隆已有仓库 12git clone &lt;repo&gt; # 在某个文件内执行，会在该文件里生成一个仓库git clone &lt;repo&gt; &lt;directory&gt; # 克隆仓库到指定目录 clone 做了4件事： repo的文件夹被创建； 仓库的所有文件和提交都被下载到repo内； 在repo文件内初始化一个git仓库； 一个远程分支origin被创建,关联了该URL； 本地有一个分支（默认名字为master）。 四种协议克隆 12345678# SSH 协议git clone git@github.com:fsliurujie/test.git# HTTPS 协议git clone https://github.com/fsliurujie/test.git# GIT协议git clone git://github.com/fsliurujie/test.git# HTTP 协议git clone http:////github.com/fsliurujie/test.git ssh vs https ssh 和 http 是常见的两种克隆方法： 协议 是否配置SSH key 速度 PUSH ssh √ 快 仓库管理员无需密码 https × 较慢 需要用户名和密码 创建仓库时可能会用到的其他操作： 创建文件夹: mkdir fileName 创建目录 创建文件: touch documentName 创建文件 删除文件 ： rm fileName 删除非空文件夹 强制删除非空文件 ： rm -rf fileName f -force 强制删除文件（夹），没有提示 -r–recursive 递归删除 删除空文件可用这个 添加更改 添加跟踪的文件之前，一般需要设置排除跟踪的文件，即创建.gitignore文件。 不知道如何编写？复制来，按需修改即可。 各种项目的gitignore模板 12345git add &lt;fileName&gt; # 添加某一个文件到暂存区git add *.js # 增加所有 js 文件的修改git add -u # git add --update 添加修改（modified)和删除（delete）文件（跟踪的文件），不添加（new）新增文件git add . # 添加新增和修改，不添加删除git add -A # git add -all, 合并 git add -u 和 git add . 即添加新增、修改和删除 重命名已跟踪的文件 1git mv old-name new-name 该命令和直接重命名文件，然后 git rm old-file,git add new-old是一样的。 撤销修改 在 commit 提交前，不想添加修改，可撤掉更改—文件修改会消失，这是非常危险的操作 除非你确实清楚不想要那个文件了，否则不要使用这个命令。 12# -- 必须有，没有是分支切换命令git checkout --file add 后修改，checkout回到最近一次add后的状态，还未 add 的更改消失； commit后修改，checkout回到最近一次commit 后的状态，更改消失； 总的来说，checkout 是撤掉修改。 添加文件也是一种修改，checkout的另一个作用是找回删错的文件： 12git rm file # file 不是你想删除的文件，git checkout --file # 找回误删的文件，但是最近一次 add/commit 后的修改丢失了 从暂存区撤回 -从暂存区撤回：git rm --cached usage: git rm [] [–] … -n, --dry-run dry run -q, --quiet do not list removed files –cached only remove from the index -f, --force override the up-to-date check -r allow recursive removal –ignore-unmatch exit with a zero status even if nothing matched 撤回很多文件如何操作？？？ commit 相关操作 提交更改到仓库 12git commit -m 提交说明git commit -a # 在编辑器中写提交说明 合并 commit 1git log # 查看提交历史 当前历史： 123456commit a00766289ef....... 待合并commitcommit 22281fca7bf....... 第三方库和业务代码分开打包commit 7828194fe69....... 各页面分开打包 需要合并’待合并commit’和’第三方库和业务代码分开打包’ 先 rebase 操作： 1git rebase -i 7828194f # 参数 i 是不需要合并的commit 执行完该命令，会进入交互模式： 123456789101112131415161718192021p e2d34a8 脚本配置自定义参数s 004fb27 修改README# Rebase bd25857..004fb27 onto bd25857 (2 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out pick 会执行 commit squash 该 commit 会合并到前一个commit 把第二条命令改为s，保存并退出，会进入commit message 编辑界面，可编辑新的commit message。 1234567891011121314151617181920212223242526272829# This is a combination of 2 commits.# This is the 1st commit message:脚本配置自定义参数# This is the commit message #2:修改README# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## Date: Fri Feb 15 17:31:30 2019 +0800## interactive rebase in progress; onto bd25857# Last commands done (2 commands done):# pick e2d34a8 脚本配置自定义参数# squash 004fb27 修改README# No commands remaining.# You are currently rebasing branch 'master' on 'bd25857'.## Changes to be committed:# modified: .gitignore# modified: README.md# new file: config/default.js# new file: config/dev.js# modified: package.json# modified: webpack.config.js# 修改比较 git diff git status 命令是查看仓库状态，文件是否被修改，修改会哪些文件还没提交等，不知道修改的具体内容。 -查看修改的内容：git diff 比较的是 暂存区的文件和本地文件。 有变化的内会用红色和绿色标记 版本回退 查看提交记录 12git log git log --pretty=oneline #在一行显示提交记录 版本回退 HEAD : 表示当前版本。 我们可回退到其他版本。 HEAD^ ：上一个版本，HEAD^^ ： 上上个版本。 HEAD~n ：往前第 n 个版本。 12git reset --hard &lt;commitID&gt; # 回退到 commitID 为版本 推荐使用git reset --hard HEAD~n # 回退到往前第 n 个版本 回退我反悔了，又想回到之前的版本呢？ 查看 commitID: 1git reflog 版本穿梭 1git reset --hard commitID # 根据commitID 回退 工作区和暂存区 工作区（工作目录） : 本地电脑文件夹，该文件夹里有你需要版本控制的文件。 版本仓库Repository：工作区里有一个隐藏的 .git 文件夹，这不是工作区，这是 Git 仓库。 暂存区Stage：版本仓库里有暂存区区，Git add 先添加到这里。 分支 : 仓库里有一个分支，git commit 把修改从暂存区提交到分支，一本版本仓库里可能有多个分支。 status 和 diff 比较的是哪些？ diff 的比较 diff 可比较工作区和暂存区、工作区和HEAD、暂存区和 HEAD、两个分支、两个提交、两个文件、两个 bolb之间的差异。 工作区和暂存区的比较 12git diff # 比较所有文件git diff -- file1 file2 # 比较个别文件 暂存区和 HEAD 比较 123git diff --cached # 暂存区和HEAD的比较 比较所有文件git diff --cached -- file1 file2 比较个别文件git diff --staged # 暂存区和HEAD的比较 工作区和 HEAD 比较 12git diff HEAD # 比较所有文件git diff HEAD -- file1 file2 # 比较个别文件 分支比较 1234git diff branch-name # 分支 branch-name 的 HEAD 和当前分支 HEAD 比较git diff branch-name1 branch-name2 # 两个分支的 HEAD 比较git diff HEAD HEAD~1 # 当前 HEAD 和上一个 HEAD 比较（两个 commit 的比较）git diff commitID1 commitID2 # 两个 commit 的比较 输出比较结果 1git diff &gt;&gt; diff.txt # 将比较结果输出到 diff.txt 文件中 status 的比较 实验： 修改→status：文件被修改，还没提交到暂存区。可以 git add，或者 git checkout --file 放弃更改 ; 修改→add→status：提示更改没commit，可以git reset回退版本。 修改→add→修改→status：提示更改没commit，可以git reset回退版本。 提示 文件被修改，还没提交到暂存区。可以 git add，或者 git checkout --file 放弃更改 ； 修改→add→commit→status：工作区干净。 结论： 提示没有commit，比较的是暂存区和分支，可进行commit 或者 reset ; 提示没有 add，比较的是工作区和暂存区，可 add 到暂存区和 checkout ，放弃更改； status 比较的是工作区和暂存区，暂存区和分支，不比较工作区和分支。 撤销修改 撤销修改:git checkout – file， 文件回到最后一次 add 的状态。 两种情况： 1.修改后还没add：回到最近的版本库； 2.修改后已add : 回到 add 之前的状态。 - - 很重要，没有它就不是撤销修改，而是切换分支 git checkout – . 撤销所有修改 git checkout path/…/file 撤销文件下中某个文件的修改 git reset HEAD file 可以回退版本，也可从暂存区回到工作区。 删除文件 在工作区删除文件：rm file 在工作删除文件后，工作区和仓库版本不一致了，可以有两个操作： 误删了，就把版本库里的最新版本，拿到工作区。 git checkout – file 确认删除，那再把版本库里的文件删除。git rm file 注意 git rm file 和 rm 的区别： git rm file:删除暂存区和工作区，需用用 git checkeout HEAD – file 或者 git checktout HEAD file分支恢复。 远程仓库 在 Github 上创建仓库并关联本地仓库 Git 是分布式版本控制系统，同一个 Git 版本仓库，可分布到不同的机器上，这些机器上的版本库都是一样的。现在只有一台机器，如何分布？ **①：在 Github 上创建仓库，将代码推送到该仓库。**推荐做法 ②：分布在同一台机器上的不同目录，硬盘坏了所有版本库都没了，不推荐，（也不知道怎么弄）。 ③：建一台服务器，从该服务器上克隆版本库，提交版本库到该服务器。成本高，适合公司多人协作开发。 关联远程仓库 1git remote add origin &lt;repoUrl&gt; origin 是默认的远程仓库的名字，可取其他名。远程仓库可有多个分支。 “origin” 并无特殊含义 远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master 查看远程仓库 1git remote -v # 显示所有远程仓库 删除本地分支和远程分支的关联 1git remote remove origin 推送本地修改到远程仓库 第一次推送本地仓库到远程仓库 1git push -u origin master # master 是分支名字 非第一次推送 开始工作前，远程仓库可能有更新,需要先合并。 分支合并 合并分支方法一（推荐） 获取远程仓库某个分支的更改： 1git fetch origin &lt;remote-branch&gt;:&lt;temp-branch&gt; 该命令做了两件事情： ①. 创建本地分支 temp-branch; ②. 将remote-branch上的更新保存在 temp-branch 中 与当前分支比较不同： 1git diff &lt;temp-branch&gt; 将更改合并到当前分支： 1git merge &lt;temp-branch&gt; # &lt;temp-branch&gt; 是合并进`当前分支`的分支 合并成功会没提示，并且在当前分支上有一个合并进来的分支的提交记录。 合并分支方法二 获取更改 1git fetch &lt;remote&gt; # 获取远程仓库的更改，是哪个分支呢？remote 远程仓库名字，一般是 origin 合并 1git merge &lt;remote&gt;/&lt;local-branch&gt; # 将更改合并进入local-branch 分支合并方法三 以上两个操作合并为一个操作： 1git pull &lt;remote&gt; &lt;local-branch&gt; 出现Already up to date.,则合并成功。 pull会自动合并，执行该命令前，需要确保当前分支的修改都提交了，需要提交的修改，可能会使你的修改丢失。执行成功后，有冲突，会显示冲突的文件。 如果你不想自动合并，可执行git merge --abort撤销pull。 以上参考：fetching-a-remote 执行git merge --abort可能会出现fatal: There is no merge to abort (MERGE_HEAD missing).的提示，说明撤销合并没成功。（因为合并成功，合并分支被删除了？） 可用 git reset --merge来撤销合并。 注意：当MERGE_HEAD存在，git reset --merge和git merge --abort是相同的。 参考：undoing git merge after merge.renameLimit warning plus conflicts 合并完后，进行编辑，提交修改，最后推送： 1git push &lt;remote&gt; &lt;remote-branch&gt; # &lt;remote-branch&gt; 是你工作的远程分支名字，可能别人和你在该分支是上工作 强制覆盖合并 123git fetch --all git reset --hard origin/master git pull 如何避免每次输入密码? 执行某些操作，Git 服务器会询问用户名与密码。可在本地设置保存密码，提高效率。 短期凭证存储 凭证保存在内存中，几分钟内有效。 1git config --global credential.helper cache 长期凭证存储 凭证保存在硬盘内，长期有效。 1git config --global credential.helper store ##分支管理 查看分支 git branch [-r] [-a] [-v] 1git branch -av # 推荐使用，可参看本地分支和远程分支，并且可看最近的提交 1git branch # 查看本地分支 1git branch -r # 查看远程分支 1git branch -a # 查看所有分支 新建分支 1git branch [-f] new-branch # 新建分支 -f 可选 1git checkout new-branch # 切换分支 1git checkout -b new-branch # 新建并切换 删除本地分支 1git branch -D need-delete-local-branch # 在当前分支下删除自身，不可删除 删除错了，恢复： 1git reflog # 查看操作日志，找到需要恢复的commit id 1git branch need-recover-branch commitId # 恢复分支 本地分支和远程分支都删除了，怎么恢复？ 先恢复本地分支，再 push 一次，即恢复了本地和远程分支 删除远程分支 远程以remote/branch 形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 1git branch origin -d remote-branch git branch -r -d origin/remote-branch-name git branch -d -r origin/remote-branch-name 1234git push origin --delete origin/&lt;remote-branch&gt;git push origin :&lt;remote-bracnh&gt;# 给出本地分支 是推送远程分支git push origin &lt;local-branch&gt;:&lt;remote-bracnh&gt; 删除了，但是产生一个问题：其他成员在pull代码时，不会把删除本地的分支 fetch 时 加 -p git fetch -p 重命名分支 删除远程分支→重命名本地分支→ push 分支到远程仓库 本地分支重命名： 1git branch -m old-branch-name new-branch-name # 重命名当前分支，可省略 old-branch-name push 新分支分支到远程仓库： 1git push origin new-branch-name 已跟踪的文件取消跟踪 有的文件忘记加入到 .gitignore，git add .后Git 就会默认追踪该文件，追踪后取消追踪的操作： 从追踪列表中删除： 123456789# 删除某个文件git rm --cached &lt;file&gt;# 可加 -r 选项 表示递归删除 带目录时加 -rgit rm -r --cached &lt;directory&gt;# 删除整个目录git rm --cached . # 删除某个目录下的所有文件# * 加 \ 是为了从 git 命令中转译git rm --cached src/\* 该操作 从仓库索引中取消文件跟踪，文件仍然保留在工作目录中。 2. 增加刚才的文件或者目录到 .gitignore 3. 提交更改 12git add .git commit -m '文件取消跟踪' 推送至远程 推送至远程后，远程仓库不再用取消忽略的文件。 Tell Git not to track a file any more (remove from repo) How to make Git “forget” about a file that was tracked but is now in .gitignore? 删除已跟踪的文件 希望从工作目录中删除已跟踪的文件，必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 0. 修改.gitingnore 删除文件跟踪 12git rm &lt;file&gt;git rm -r &lt;dir&gt;\*.md 执行该操作，项目仓库中不再有该文件。 2. 提交更改 1git add . .gitignore 文件相关 忽略规则 .gitignore 列出的目录或者文件是不被 git 跟踪的。常常需要忽略的文件如下： 临时资源，比如缓存、日志、编译后的源码等； 开发环境配置文件，不同的开发人员有不同的开发习惯，环境配置文件不该被跟踪； 敏感信息，比如数据库密码、秘钥等。 匹配规则：会以 .gitignore 所在目录为顶级目录或者当前目录，递归地匹配路径或文件，后面的规则会覆盖前面的规则。 一个文件或者目录被忽略，不会有以下行为： 被 git 跟踪； 反映到 git status 或 git diff等命令中； 被暂存，比如 git add -A 不会暂存被忽略的文件。 常见的规则模式 # 是注释，注释不能和规则同行，否则规则失效。规则含有 #，使用反斜线 / 转义。 常用规则 123456789101112131415161718# 某类型文件，使用扩展名*.js*.log# 排除特定文件!index.js# 特定文件index.csstest.json# 目录及其内容node_modules/# 当前目录下的某个目录 .gitignore 所在目录为顶级目录/node_modules/# 任意目录或文件node_modules# 当前目录下的任意目录或文件/node_modules 高级规则 123456789101112131415161718# 子目录 两层关系target/logs/# 孙子目录 三层关系target/*/logs/# 后代目录 任意层关系target/**/logs/# 可选字符匹配 # 匹配 build/Build 文件或目录 Build 不会匹配 uild[bB]uild # 匹配 .pyc 或 .pyo.py[co]# 特定目录下文件target/*/.bin/*.js# 目录匹配通配符# 匹配 .deploy_git .deployB.deploy*/ 其他忽略方式 .gitingore 文件应该被提交到仓库里，但是会暴露你的忽略规则，如果不想暴露，可使用以下方式设置： .git/info/exclude 文件配置； 配置全局忽略文件。 常见项目的 .gitignore 文件 常见gitignore模板 在线生成gitignore文件 列出忽略的文件 git status 1git status --ignored git ls-files 1git ls-files --others -i --exclude-standard 删除忽略文件 git clean -x 可删除忽略文件,和 git reset --hard 一起使用可完全回到某个 commit 状态。 12345678910git clean -n # clean 演练，告知哪些文件会被删除# 删除当前目录下所有没有 track 的文件，不删除 .gitignore 文件里的文件git clean -f &lt;path&gt; # 指定路径 path# 删除当前目录下没有被 track 的文件和目录git clean -df# 所有没有被 track 的目录和文件，不管 .gitignore 是否匹配git clean -xf# 列出被跟踪的文件 1git ls-tree -r master --name-only 常见问题 本地仓库版本落后于远程仓库版本 当push到远程仓库时，出现以下错误： 1Updates were rejected because the tip of your current branch is behind 解决办法： 强推（远程修改会丢失） 1git push origin -f master 先合并，再推送（待验证） 12git pull origin mastergit push origin master 不想合并，先建分支，再推送（待验证） 12git branch &lt;branch-name&gt;git push origin &lt;branch-name&gt; # 待验证 Git推送提示：remote origin already exists 删除远程仓库 (删除报错，可在配置文件中删除仓库信息) git remote rm origin 在添加远程仓库 git remote add origin repo-url 再次推送 git push -u origin master todo git relog VS git log Undo changes in Git - Cheat sheet for git checkout, stash, reset, clean, revert, rebase -i, amend temporary_undo_and_red git 进阶 A Hacker’s Guide to Git Git – Fast Forward 和 no fast foward]]></content>
      <categories>
        <category>版本控制</category>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册一个美区的 Apple ID]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E7%BE%8E%E5%8C%BAappleID%2F</url>
    <content type="text"><![CDATA[众所周知的原因，app store 某些应用在国内下载不了，需要一个美国的 apple id 才能下载。以前试过，没成功就，就用共享的账号，不仅麻烦，还有安全隐私泄露的隐患，今天又试着注册一个，成功了，记录一下我的操作过程，给需要的人一些指南。 需要准备的东西 一个 IP 在美国的梯子； 美国个人信息，使用fakeaddressgenerato，生成； chorme 浏览器，需要使用匿名模式； iphone； 邮箱，推荐 gmail； ip检测网站（可选），推荐ipip； 美国信用卡，没有就不能下载付费应用，可选。 操作步骤 使用梯子，ip 必须在美国的，全局模式访问，为了确保正确，可使用ip检测网站检测一下； 生成假的美国信息，推荐使用免税区的地址 Oregon 俄勒冈、 Alaska 阿拉斯加 Delaware 特拉华州 Montana 蒙大拿 New Hampshire 新罕布什尔 目前我还没遇到付款相关问题 浏览器开启匿名模式【Ctrl + Shift + N】，不然苹果会根据你的访记录，不让访问美区的那内容。这里可清除浏览器缓存再开启匿名模式，确保万无一失嘛。 网站苹果网站，正常注册账号就好了，需要填信息，就用刚才的假信息。以上步骤都顺利，是不要求添加银行卡号的。 使用新的账号登录 App Store 登录成功后，改变Apple id 地区，使用假信息填写账单信息； App Store 变成英文界面，就可以了。 为了以后方便使用，可以把假信息记录下来，可能以后会用到。 我的美国信息 12345678910111213141516171819BASIC INFORMATIONFull name Eunice G GiffordGender femaleTitle Ms.Race WhiteBirthday 7/3/1989Social Security Number 503-46-3607ADDRESSStreet 2509 Hartway StreetCity ANTELOPEState ORState Full OregonZip Code 97001Phone Number 605-720-5251Mobile Number 541-813-5999Temporary email w7v8guupr2c@claimab.com This is a real email address, click here to recieve mails 貌似以上信息就够了，先保存这么多吧。]]></content>
      <categories>
        <category>数字生活</category>
      </categories>
      <tags>
        <tag>数码产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2019%2F06%2F20%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[连续触发（触发频率很高）的事件，不进行优化，会出现页面卡顿现象。 常见的需要优化的事件： 鼠标事件: mousemove（拖拽） mouseover(划过) mouseWheel(滚屏) 键盘事件： keydown(按下键盘) keypress（按下字符键盘） keyup(弹起键盘) window resize/scroll DOM 元素动态定位 优化方式是控制事件处理器在一段时间内的执行次。 防抖 频繁（连续）触发事件（比如用户触发输入事件input），不执行目标动作，当不在触发事件了，再执行。 实现思路，在事件处理器内，使用 setTimeout 包裹目标动作，一直触发事件，就清除上次的定时器，不再触发触发事件，会执行最后一个定时器，目标动作也执行一次了。 1&lt;input type="text" id="input" /&gt; JS代码： 123456789101112131415161718function debounce(callback, delay) &#123; let timeout = 0; return e =&gt; &#123; console.log('清除', timeout, new Date()); clearTimeout(timeout); //input 一直触发，就清除上一次的定时器，防止执行目标函数，直到事件不触发事件，最后一个定时器没有清除，delay 时间后就会执定时器，就确保了目标函数只执行一次。 timeout = setTimeout(() =&gt; &#123; callback(e); &#125;, delay); console.log('新的', timeout, e.target.value, new Date()); &#125;;&#125;let print = debounce(e =&gt; &#123; let value = e.target.value; console.log(value, new Date());&#125;, 1000);document .querySelector('#input') .addEventListener('input', print, false); 清除定时器的时机很关键，在新定时器生成之前，如果在之后，会将所有定时器都清除，目标函数一次都不执行。 节流 防抖是多次触发事件，目标函数只执行一次，不管触发这些事件用了多少时间。而节流是在一段时间内，确保目标函数只执行一次，实现缓慢执行目标函数的效果。 上面的输入使用节流实现： 12345678910111213141516171819202122232425let thorttle = (callback, delay) =&gt; &#123; let timeout = 0; let now = new Date() - 0; return e =&gt; &#123; console.log('now', now); let last = new Date() - 0; clearTimeout(timeout); if (last - now &gt;= delay) &#123; console.log('时间间隔', last - now); callback(e); now = last;//将上执行的时间赋值给 now &#125; else &#123; //将 delay 时间内多次触发事件，目标函数合并到这里执行 timeout = setTimeout(() =&gt; &#123; callback(e); &#125;, delay); &#125; &#125;;&#125;;let write = thorttle(e =&gt; &#123; console.log(e.target.value, new Date());&#125;, 5000);document .querySelector('#input') .addEventListener('input', write, false); 两者比较 节流在某个时间段内，目标函数能执行一次，限制目标函数的执行频率，不管事件触发了多少次； 防抖是多次触发事件，目标函数只执行一次，不管触发了这些事件用了多少时间。 节流函数限制目标函数的执行频率，有连续变化的效果，适用于关注变化过程的操作，可以调整目标函数执行频率使得变化更加平滑，比如动画、改变窗口时执行某些操作等，常用事件resize、scroll、mouseWheel、touchmove、mouseover等； 防抖函数适用于更关注结果的操作，不太关注操作过程，常见的事件有 input、keyup等。 最后看一个 将 防抖 和 节流都用 resize 事件的效果，更能体会两者的区别： 12345678910111213141516171819202122232425262728293031323334function debounce(callback, delay) &#123; let timeout = 0; return e =&gt; &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback(e); &#125;, delay); &#125;;&#125;let print = debounce(e =&gt; &#123; let value = e.target.value; console.log('debounce', window.innerWidth);&#125;, 500);let thorttle = (callback, delay) =&gt; &#123; let timeout = 0; let now = new Date() - 0; return e =&gt; &#123; let last = new Date() - 0; clearTimeout(timeout); if (last - now &gt;= delay) &#123; callback(e); now = last; &#125; else &#123; timeout = setTimeout(() =&gt; &#123; callback(e); &#125;, delay); &#125; &#125;;&#125;;let write = thorttle(e =&gt; &#123; console.log('thorttle', window.innerWidth);&#125;, 500);window.addEventListener('resize', write, false);window.addEventListener('resize', print, false); 参考 函数节流与函数防抖 函数防抖与函数节流]]></content>
      <categories>
        <category>概念深入</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 语义化版本]]></title>
    <url>%2F2019%2F06%2F16%2Fnpm-%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[为了在软件版本号中包含更多意义，反映代码所做的修改，产生了语义化版本，软件的使用者能从版本号中推测软件做的修改。npm 包使用语义化版控制，我们可安装一定版本范围的依赖，npm 会选择和你指定的版本相匹配的**(latest)最新版本**安装。 npm 的版本号由三部分组成： 主版本号、次版本号、补丁版本号。变更不同的版本号，表示不同的意义： 主版本号（major）：软件做了不兼容的变更（breaking change 重大变更）； 次版本号（minor）：添加功能或者废弃功能，向下兼容； 补丁版本号（patch）：bug 修复，向下兼容。 有时候为了表达更加确切的版本，还会在版本号后面添加标签或者扩展，来说明是预发布版本或者测试版本等。比如 3.2.3-beta-3。 常见的标签有 : 标签 意义 补充 demo demo版本 可能用于验证问题的版本 dev 开发版 开发阶段用的，bug 多，体积较大等特点，功能不完善 alpha α版本 用于内部交流或者测试人员测试 beta 测试版(β版本) 较α版本，有较大的改进，但是还是有bug gamma （γ）伽马版本 较α和β版本有很大的改进，与稳定版相差无几，用户可使用 trial 试用版本 本软件通常都有时间限制，过期之后用户如果希望继续使用，一般得交纳一定的费用进行注册或购买。有些试用版软件还在功能上做了一定的限制。 stable 稳定版 csp 内容安装版本 js库常用 latest 最新版本 不指定版本和标签，npm 默认安装最新版 更多关于标签的内容 查看标签： 1npm dist-tags ls &lt;pkg&gt; 1npm dist-tags ls vue 得到： 123beta: 2.6.0-beta.3csp: 1.0.28-csplatest: 2.6.10 安装带标签的版本 1npm i &lt;pkg&gt;@&lt;tag&gt; 1npm i vue@beta # 安装 2.6.0-beta.3 版本号变更规则 版本号只升不降，不得在数字前加0，比如 2.01.2 不允许的； 0.y.z，处于开发阶段的版本； 第一个正式版版本往往命名为 1.0.0； 先行版本必须在补丁版本之后添加，比如 2.3.7-0,- 后面的是先行版本； 版本的比较依次比较主版本→次版本→补丁版本→先行版本，直到第一个能得出比较结果为止。 不小心把一个不兼容的改版当成了次版本号发行了该怎么办？一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。 NPM版本计算器 如何处理即将弃用的功能？ 弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。但当你弃用公共API的一部分时，你应该做两件事： （1）更新文档以便使用者知道这个变化。 （2）发行不包含弃用功能的次版本。在新的主版本中完全移除弃用功能前，至少应有一个不包含弃用功能的副版本发布，以便使用者能够平滑过渡到新API。 如何更新版本号？不用手动修改 package.json。而是用如下命令： 1npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git] newversion: 直接给一个版本号； major:主版本增加1； premajor:预备主版本，主版本增加1，增加先行版本号； prelease:预先发布版本，先行版本号增加1； git 和 npm version 结合 手动更改版本号 执行 npm version &lt;version&gt; -m 'xx %s xx' 改变npm版本的同时，会执行一次 git commt -m 'xx %s xx'并用版本号打一个tag，%s 会替换成版本号，前提是版本库是干净的（clean）。 自动更新版本 在 .git/hooks目录内，新建post-commit,输入以下内容： 1234567#!/bin/shCOMMIT_MSG="$(git log --pretty=format:"%s" -1 head)"echo "$COMMIT_MSG" | grep -q "^[0-9]"if [ $? -ne 0 ];then # 自动修改 patch echo $(npm version patch)fi 在执行 git commit -m 'message'后，会检测message是否是版本号（y.x.z的形式），不是，则执行 npm version patch更新补丁版本，打一个tag。 如果想自动修改次版本，修改 post-commit 的内容即可。 版本运算符 版本运算符指定了一定范围的版本。主要有**~、^、-、&lt;、&lt;=、&gt;、&gt;=、=**版本运算符。 ~ 版本号 ----- 指定主版本号或者次版本号相同 ~ + 只含主版本 — 主版本相同； 含有次版本 — 主版本和次版本号相同。 版本范围 匹配版本 ~3 3.x 或者 3.0.0 &lt;= v &lt; 4.0.0 ~3.1 3.1.x 或者 3.1.0 &lt;= v ❤️.2.0 ~3.1.2 3.1.2 &lt; v &lt; 3.2.0 指定的版本范围含有预发布版本，只会匹配和完整版本号相同的预发布版本。 ~3.1.3-beta.2 匹配 3.1.3-beat.3 不匹配 3.1.4-beat-2 1234npm i lodash@~3 # 安装 3.10.1npm i lodash@~3.9 # 安装 3.9.3npm i lodash@~3.9.1 # 安装 3.9.3npm i lodash@~3.8.0 # 安装 3.8.0 ^ 版本号 — 第一个非零 版本号相同 版本范围 匹配版本 补充 ^3.1.5 3.1.5 &lt;= v &lt; 4.0.0 ^0.3.6 0.3.6 &lt;= v &lt; 0.4.0 ^0.0.2 0.0.2 &lt;= v &lt; 0.0.3 ^3.x.x 3.0.0 &lt;= v &lt; 4.0.0 版本号缺少的位置，会被 0 填充 ^4.2.x 4.2.0 &lt;= v &lt; 4.3.0 npm 安装包时，默认使用 ^ 匹配版本。 安装主版本号为 3 的最新版本： 123npm i lodash@^3 # 安装 3.10.1npm i lodash@^3.9 # 安装 3.10.1npm i lodash@^3.8.0 # 安装 3.10.1 ~ vs ^ 版本范围 含义 匹配的版本 说明 ~3.3.0 与3.3.0相似 3.3.0 &lt;= v &lt; 3.4.0 主版本和次版本相同 ^3.3.0 与3.3.0兼容 3.3.0 &lt;= v &lt; 4 主版本相同 同一个版本号，^ 能匹配的范围大些，更加激进。 例子 12npm i lodash@^3.3.0 # 安装 3.10.1npm i lodash@~3.3.0 # 安装 3.3.1 ~ 和 ≈ 差不多，可将 ~ 理解成相似，这样就分辨了和理解了，~指定的是相似版本。 ^ 可理解成兼容版本。 - 指定精确范围 版本范围 匹配版本 补充 2.0.0 - 3.2.7 2.0.0 &lt;= v &lt;= 3.2.7 - 前后有空格 0.4 - 3 0.4.0 &lt;= v &lt;= 3.0.0 缺少的版本号，被 0 填充 1npm i vue@"1 - 1.9" # 安装 1.0.28 版本号比较器 版本范围 匹配版本 补充 &lt;2.2.0 小于2.2.0 的版本 &lt;=2.0.0 小于等于 2.0.0 的版本 &gt;4.2.0 大于4.2.0 的版本 &gt;=4.2.0 大于等于 4.2.0 的版本 =4.3.0 等于 4.3.0 的版本 \ 是转义字符。 12345npm i lodash@\&lt;3.5 # 安装 3.4.0npm i lodash@\&lt;=3.5 # 安装 3.5.0npm i lodash@\&gt;3.5 # 安装 4.17.11npm i lodash@\&gt;=3.5 # 安装 4.17.11npm i vue@"&gt;1 &lt;2.3" # 安装 2.2.6 分组 || (几乎不用) 版本范围 匹配版本 ~2 || ^0.7 匹配2.0.2&lt;= v &lt; 3.0.0 或者 0.7 &lt;= v &lt;1.0.0 1npm i vue@"^0.7 || ~2" # 安装 2.6.10 最新的版本 参考 依赖的版本 版本号管理策略&amp;&amp;使用npm管理项目版本号 语义化版本2.0 whats-the-difference-between-tilde-and-caret-in-package-json]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 中的 ES 模块]]></title>
    <url>%2F2019%2F06%2F16%2Fnode-%E4%B8%AD%E7%9A%84-ES-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[[TOC] ES6 模块的设计思想是尽量静态化，在编译时就能确定依赖关系，以及输入和输出变量，是编译时加载。编译时加载可实现静态优化，类型检查等都在静态分析实现。CommmonJS 是运行时加载，加载的是对象，不能静态优化。ES6 模块不是对象，而是通过 export 命令显示输出代码，再通过import导出。 目前 node 对 ES6 的支持尚处在实验阶段，可编写.mjs 和给 node 命令增加--experimental-modules 使用 ES6 模块。 ES6 自动启用严格模式 有以下限制： 变量必须先声明再使用； 不能删除变量delte prop,只能删除属性delete global[prop]; arguments不随函数参数变化； 禁止 this指向全局对象，顶层 this 指向 undefined； 增加保留字protected、satic、interface等。 导出接口 导出接口使用 export 命令。一个模块就是一个独立的文件，文件内部的变量，外部王无法获取。 export 命令 逐个导出接口： 123456// name.mjsexport let firstName = 'JACK';export let lastName = 'Zhou';export let myFun = () =&gt; &#123; console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`);&#125;; 引入接口： 大括号里面的接口名，必须和导出的相同。 1234//app.mjsimport &#123; firstName,lastName,myFun &#125; from "./name";console.log(firstName +' '+ lastName);myFun() 统一导出： 如果不想暴露内部变量的名字，可用as指定导出名 1234567let firstName = 'JACK';let lastName = 'Zhou';let myFun = () =&gt; &#123; console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`);&#125;;setTimeout(() =&gt; (firstName = 'HaHa'), 10); //在10毫秒后改变导出接口的值export &#123; firstName as name, lastName, myFun &#125;; 引入： 可用as给导出的接口取一个别名。 1234567import &#123; name as firstName, lastName, myFun &#125; from './name';console.log(firstName + ' ' + lastName);myFun();// 2秒后输出新的值 HaHasetTimeout(() =&gt; &#123; console.log(firstName);&#125;, 2000); 输出： 123JACK ZHOUJACK ZHOUHaha **setTimeout(() =&gt; (firstName = ‘HAHHAH’), 10);**在10毫秒后改变导出接口的值。export 导出的接口和值是动态绑定的。即可通过接口获取模块内部实时的值。这和CommonJS 规范完全不同，其保存的是模块内的缓存。 导出的接口是常量，不可修改，否则报TypeError:Assingment to constant variable.。但是可修改对象，包括数组、包装对象等。 但是不推荐这么做，，容易出错，还难以调试 12345678910111213//my.mjslet firstName = 'JACK';let lastName = 'Zhou';let myFun = () =&gt; &#123; console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`);&#125;;let obj = &#123; age: 10, ID: '1313134'&#125;;let arr = ['1', '2'];let oNum= new Number(12)export &#123; arr, obj ,myFun,oNum&#125;; 引入： 123456789101112import &#123; arr, obj, myFun, oNum &#125; from './name';console.log(obj);obj.age++; #修改对象console.log(obj);arr.push('你好'); # 修改数组 数组是特殊的对象console.log(arr); myFun();// myFun=()=&gt;'周杰' 这里报错console.log(oNum.valueOf());oNum.age = 20;console.log(oNum);console.log(oNum.age); 整体引入,修改上述引入方法： 12import * as OBJ from './name';console.log(OBJ.obj); 用*****指定一个对象，将接口都加载到好对象上。 import 提升效果： 12console.log(OBJ.obj);import * as OBJ from './name'; 这种效果的本质是模块在编译时加载，而非运行时。 加载时可不暴露任何接口。那这样有和作用呢？如何调用接口？？ 12import './name'; import './name'; //多次加载，只会执行一次 比如 vue 自定义指令，已经在指令定义文件中使用 Vue.directive函数定义指令了，就可以不导出接口，引入时也不需要导入任何接口。 123456789import json from './json';import Vue from 'vue';const directives = &#123; json&#125;;for (const [key, value] of Object.entries(directives)) &#123; Vue.directive(key, value);&#125;// export &#123;json&#125; 在main.js 引入： 12// 自定义指令 这里不需要导入任何接口import './directives'; export default 命令 上面接口的导出方式，在引入时都需要先知道接口名字，否则无法加载。但是用户往往不想要先阅读文档，了解接口。export default就是为模块指定默认接口的，引入时接口名可随意命名。 1234567891011121314//my.mjslet firstName = 'JACK';let lastName = 'Zhou';let myFun = () =&gt; &#123; console.log(`$&#123;firstName&#125; $&#123;lastName&#125;`);&#125;;let obj = &#123; age: 10, ID: '1313134'&#125;;let arr = ['1', '2'];let oNum = new Number(12);export &#123; obj, myFun, oNum &#125;;export default arr; //默认接口 一个模块只能有一个 引入； 123456import Obj from './name'; //将默认接口加载到 Obj 上console.log(Obj);import &#123; obj, myFun, oNum &#125; from './name'; //引入命名接口console.log(obj);console.log(myFun);console.log(oNum); export default Interface 的实质是将接口命名为 default。 export default arr 和 export {arr as default}相同。 export default 导出匿名函数都是可以的，还可用来导出类。 123456789101112class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)`; &#125;&#125;let greeting = 'hello class';export &#123; greeting &#125;; // export default 可和多个export 混用export default Point; 引入接口: 12345import Point, &#123; greeting &#125; from './Point';console.log(greeting);let point = new Point(3, 4);console.log(point.toString());console.log(point instanceof Point); 引入接口 总结 import 命令经静态分析后先于其他语句执行； import from ,from 指定模块位置，可以是相对路径或者绝对路径，不带路径，就需要用配置文件告诉JS引擎。 静态加载是import有提升效果，多次加载只执行一次； 引入接口时可不输出接口； as 可改写接口名字； 编译时加载可实时获取模块内部的变量。 关于是否使用大括号引入： 引入export default导出的接口，不使用大括号； 引入export导出的接口，一般使用大括号，用as整体引入就不使用大括号。 export 和 import 复合使用 import 动态引入模块 前面的加载无法实现按需加载或者动态加载，因此引入import()指令，不是函数，因此不具备函数的特性，比如调用apply、bind、从Function.prototype获得继承，返回Promise对象，模块会作为then方法的参数。import 能接受的参数，import()都能接受。 require是异步动态记载，import() 是动态同步加载。 import() 适用场景 按需加载和条件加载； 路径动态改变的模块； 例子： 1234567//dynam.mjslet n = 10;let sayHello = name =&gt; &#123; console.log('hello', name);&#125;;export &#123; n &#125;;export default sayHello; 引入模块： 12345678if (true) &#123; import('./dynamic.mjs').then(module =&gt; &#123; console.log(module) console.table(module) console.log(module.n); sayHello('JACK'); # 用 export default 导出的模块，直接在then方法里调用 &#125;);&#125; 用 export default 导出的模块，直接在then方法里直接使用接口，但是有会感觉这个接口来的太突然，推荐动态加载的模块都用 export 导出，然后在引入时解构赋值提取接口。 123456//dynamic.mjslet n = 10;let sayHello = name =&gt; &#123; console.log('hello', name);&#125;;export &#123; n, sayHello &#125;; 引入 123456if (true) &#123; import('./dynamic.mjs').then((&#123; sayHello, n &#125;) =&gt; &#123; console.log(n); sayHello('JACK'); &#125;);&#125; 使用async函数加载： 12345678if (true) &#123; dynamicLoad();&#125;async function dynamicLoad() &#123; let &#123; sayHello, n &#125; = await import('./dynamic.mjs'); console.log(n); sayHello('JACK');&#125; 模块继承 未完待续 跨模块常量 未完待续 参考 ES6 Module 的语法]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yarn 常见命令]]></title>
    <url>%2F2019%2F06%2F16%2Fyarn-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[记录一下yarn常见命令，不至于在看到人家博客了使用，不知道什么意思，至于开发使用，npm 足够了。 常用命令： 1234567891011121314yarn init #初始化package.jsonyarn add packge 添加依赖 默认开发依赖yarn add package@versionyarn add package@tagyarn # 安装项目全部依赖yarn add package --dev 安装开发依赖yarn add package --peeryarn add package --optionalyarn upgrade packgeyarn remove package]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2019%2F06%2F16%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[一个域上的文档或者脚本试图请求另一个域下的资源，就是跨域。比如 资源跳转：a链接、重定向、表单提交； 资源引入：link、script、img、iframe等标签，css background:url()、font-face; [TOC] 同源限制–狭义的跨域 同源策略（same origin policy）是一种浏览器安全策略，即只允许浏览器向同源的服务器请求资源（请求还是会发送，服务器也会响应，只是响应被浏览器拦截了），可避免浏览器遭到xss、csfr等攻击。同源：协议+域名+端口 三者相同，即使不同的域指向同一个ip，也非同源。 同源限制了几种行为： Cookie、LocalStroage 和 IndexDB 无法获取； DOM 和 JS 对象无法获得； AJAX 返回值不能获取。 容易混淆的跨域： http://www.domain.com/a.js http://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.js http://x.domain.com/b.js 主域相同，子域不同 不允许 http://domain.com/c.js 跨域解决方案 JSONP CORS WebSocket node 中间件代理 还有其他一些方法，本文主要介绍 JSONP 和 CORS。 jsonp 实现跨域 原理：具有 src 属性的标签在请求资源时，不受同源策略限制（历史遗留问题），可以通过这些标签（img、script 等）加载外域的脚本，在本域执行。 例如： 12345678&lt;!-- 在 http://127.0.0.1:8016/ 的页面内有一下标签 --&gt;&lt;script&gt;function localHandler(data) &#123; alert(data.name) &#125;&lt;/script&gt;&lt;!-- jsonp.js 脚本里有 localHandler 函数，该函数在本域有定义，加载该脚本后就会执行本域的 localHandler 处理数据 --&gt;&lt;script src="http://localhost:3001/jsonp.js"&gt;&lt;/script&gt; 12//http://localhost:3001 域下有如下脚本 jsonp.jslocalHandler(&#123;name:'jack',age:24&#125;) 关键：外域上的脚本是一个执行函数，函数参数是一个对象或者 JSON ,且与本域的处理函数同名。 问题：外域的脚本是写死了，我们如何统一本域和外域的函数名呢？ 改进1：在 src 传递过去就好，其实还可传递其他参数。 1234567&lt;script&gt;function localHandler(data) &#123;alert(data.name)&#125;&lt;/script&gt;&lt;!-- 在本域传递参数 --&gt;&lt;script src="http://localhost:3001/jsonp.js?callback=localHandler&amp;id=abc8848"&gt;&lt;/script&gt; 外域服务端处理： 12345678//node 代码let query = Url.parse(req.url, true).querylet callback = query.callback //本地传递过来的本地函数名let id = query.id //假设根据id，查询数据库，获取用户信息 userInfolet userInfo = &#123; id, name: 'jack', age: 24 &#125;let response = callback + '(' + JSON.stringify(userInfo) + ')'//将处理函数和传递的数据组合res.write(response)res.end() 问题：在本域 script 标签写死了，动态插入，会更加好。 改进2：动态插入 script 标签。 12345678910111213//本域动态插入 script 标签//处理返回数据var localHandler = function (data) &#123; console.log(data)&#125;;// 提供jsonp服务的url地址（生成的返回值都是一段javascript代码）// 将处理函数传递给服务端，这里查询 id 为 abc8848 的用户信息var url = "http://localhost:3001/jsonp?callback=localHandler&amp;id=abc8848";// 创建script标签，设置其属性var script = document.createElement('script');script.setAttribute('src', url);// 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(script); 外域服务端处理： 12345678// node 代码let query = Url.parse(req.url, true).querylet callback = query.callback //本地传递过来的本地函数名let id = query.id //假设根据id，查询数据库，获取用户信息 userInfolet userInfo = &#123; id, name: 'jack', age: 24 &#125;let response = callback + '(' + JSON.stringify(userInfo) + ')'//将处理函数和传递的数据组合res.write(response)res.end() jquery AJAX 跨域 123456789101112131415&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function () &#123; $.ajax(&#123; type: "get", async: false, url: "http://localhost:3001/jsonp?id=abc8848", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback: "localHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 &#125;) .done(json=&gt;&#123;console.log(json)&#125;) .fail(err=&gt;&#123;console.log(err)&#125;) &#125;) &lt;/script&gt; 外域服务处理同上。 jsonp 的优缺点： 优点 所有浏览器都支持。 简单。 缺点 由于返回的数据当成脚本执行，会存在脚本注入的安全问题。 只能发一次请求。 只能使用 GET 方法。 不好处理请求错误。 cors 跨域 CORS 需要浏览器和服务器同时支持。目前主流浏览器都都支持 cors，cors 通信过程浏览器自动完成，和同源通信无差别。cors 关键是服务器，只要服务器设置了CORS，就能实现跨域请求。 两种请求 满足以下两个条件的是简单请求，否则为非简单请求。 请求方法为：GET|POST|HEAD 请求头部超出以下字段： Accept|Accept-Language|Content-Language|Last-Event-ID Content-Type的值限制在application/x-www-form-urlencoded|multipart/form-data|text/plain。 简单请求和非简单请求，浏览器处理不同。 简单请求 简单请求，浏览器器直接发出CORS请求，会自动在请求头中增加 Origin 字段，告诉服务器，本次请求从哪个源（协议+域名+端口号）发起，服务器根据该源，决定是否同意本次请求。 服务响应头信息Access-Control-Allow-Origin包含源，则同意请求，否则出错，触发 XHR 的 error 事件。注意，这种错误无法根据状态码识别，因为可能为200。 简单请求，响应头信息除了Access-Control-Allow-Origin字段必须设置外，可选地设置以下字段： Access-Control-Allow-Credentials：布尔值，是否允许发起者获取响应内容。CORS 默认发送 Cookie，但是响应不携带Access-Control-Allow-Credential:true，浏览器不会把响应内容返回给请求的发起者（即该请求拿不到响应）。不需要携带认证信息，可设置请求xhr.withCredentials = false;。附带认证的请求，Access-Control-Allow-Origin必须设置一个具体的值，否则请求将失败。响应中携带 Set-Cookie字段，尝试对Cookie进行修改，失败会抛出异常。 Access-Control-Expose-Headers：CORS请求时，XHR的getResponseHeader()只能拿到6个头信息：Cache-Control|Content-Language|Content-Type|Expires|Last-Midified|Pragma。想获取到其他字段，必须在这个响应头里指定。 非简单请求 非简单请求，在发送实际请求之前，会发送一个预请求（preflight），以确定跨域信息。跨域信息包括：**允许跨域的域 + 方法 + 请求URL + 特殊的请求头字段 + credentials **。跨域信息符合实际请求，才会发起实际请求，否则报错。通过预检请求会，在跨域缓存时间内，不会再发起预检请求。 实际请求： 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);// PUT xhr.setRequestHeader('X-Custom-Header', 'value');//自定义请求头xhr.send() 浏览器检测到非简单请求，会发情预检请求： 12345678OPTIONS /cors HTTP/1.1 // OPTIONS 方法，询问跨域信息Origin: http://api.bob.com // 将要跨域的源Access-Control-Request-Method: PUT // 将要跨域的方法Access-Control-Request-Headers: X-Custom-Header // 跨域自定义字段，用逗号分隔的字符串。Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 预请求响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.com // 允许跨域的源 必需的Access-Control-Allow-Methods: GET, POST, PUT // 允许跨域的请求方法 必需的Access-Control-Allow-Headers: X-Custom-Header // 允许跨域的请求头字段 必需的Access-Control-Max-Age: 1728000 // 缓存跨域请求的时间，单位为秒，非必需Access-Control-Allow-Credentials: false // 响应内容控制，非必需Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 实际请求满足预请求响应，会自动发送实际请求，否则触发 error 事件。通过了预检请求，以后只要在跨域缓存时间内（注意，URL变了，跨域缓存信息也会失效），就和简单请求一样，携带 Origin 字段，服务器响应，有Access-Control-Allow-Origin字段。 实际请求： 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 实际响应（部分字段）： 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 CORS 优劣 优点： 支持的方法多； 更加安全。 缺点： 老旧浏览器不支持； 会多发请求。 相比 CORS 的优点，缺点可忽略。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME Type]]></title>
    <url>%2F2019%2F06%2F16%2FMIME-Type%2F</url>
    <content type="text"><![CDATA[MIME（Multipurpose Internet Mail Extensions）网络多用途邮件扩展，告知某种扩展名的文件用特定软件打开或处理，也叫 Media Type（Internet Media Type）媒体类型，浏览器从 HTTP 消息头字段 Content-Type 得知资源类型，从而能正确处理网络中传递的资源，实际上媒体类型就是指定content-type的值。 用 / 区分类型和子类型，类型指定多个类型，子类型更加明确的指定类型。不区分大小写，惯例用小写。 常见的媒体类型： text/html：HTML 格式 text/plain：普通文本 text/xml : XML 格式 image/gif : gif 图片 image/jpg : jpg 图片 image/png : png 图片 以 application 开头的媒体类型 application/json ：JSON格式数据 application/x-www-form-urlencoded：form 表单默认以 key1=val1&amp;key2=val2 的格式发送数据到服务器（表单默认提交的数据格式），并对key和value进行url编码&quot; application/pdf：pdf 格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/xml ： XML数据格式 application/atom+xml ：Atom XML 聚合格式 application/xhtml+xml ：XHTML 格式 application/xml : XML 数据格式 ##上传文件 multipart/form-data : 在表单中提交文件 enctype=“multipart/form-data” 。也可传输key=value 数据，性能损耗大，不推荐。 蓝色更为常用]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS 模块和 ES6 模块在vue中混用]]></title>
    <url>%2F2019%2F06%2F16%2FCommonJS-%E6%A8%A1%E5%9D%97%E5%92%8C-ES6-%E6%A8%A1%E5%9D%97%E5%9C%A8vue%E4%B8%AD%E6%B7%B7%E7%94%A8%2F</url>
    <content type="text"><![CDATA[commonJS 和 ES6 模块在 Vue 中混用 引发的问题。 具体情况 引入 导出 是否可行 说明 require module.exports × 报错：TypeError: Cannot assign to read only property ‘exports’ of object ‘#’ require export √ import export √ 推荐使用 import module.exports × 报错：同上 目前 node 还不支持 ES6 模块，需要用 webpack 统一模块化方案。require、module.exports 是 CommonJS 的引入导出模块方案，却不同在同一个文件内使用，这点很让人费解。 注意：目前 node 的模块化方案，只有 CommonJS，require 和 module.exports 是可以混用的。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS 规范]]></title>
    <url>%2F2019%2F06%2F16%2FCommonJS-%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[为了开发大型复杂应用、代码便于管理，制定了不同的 JS 代码模块化规范。 CommonJS：node 的模块化实现了 CommonJS 规范，同步加载。 AMD ：异步模块定义规范，异步加载，是 RequireJS 在推广过程中对模块定义的规范产出，推崇依赖前置； ES6：ES6 模块化的设计思想是尽量静态化，编译时就能确定模块依赖关系； CMD : 是 SeaJS 在推广时对模块定义的规范化产出，推崇依赖就近； UMD : 兼容 AMD 和 CommonJS 的规范化的同时，还兼容全局引用的方式。 CommonJS 规范希望JS代码能在任何地方运行，具备开发大型应用的能力，node 的模块化采用 CommonJS 规范实现。 [TOC] 模块实例 一个文件就是一个模块，有自己的作用域。文件中的变量、函数、类都是私有的，其他文件不可见。 每个模块内部，module变量代表当前模块。这是一个对象，exports 属性对导入模块的接口，require一个模块，就是加载exports属性。 12345// example.jslet x = 5;let addX = value =&gt; value + x;module.exports.x = x;module.exports.addX = addX; 123456//test.jslet example = require('./example');console.log(example);//&#123;&#125;console.log(example.x);//5let result = example.addX(3);console.log(result);//8 CommonJS 模块特点： 所有代码都运行在模块的作用域内，不会污染全局作用域； 模块可多次加载，但是只会在第一次加载时运行一次，以后加载从缓存中读取。不想要运行该模块，必须清除缓存； 按照代码出现的顺序加载。 module 对象 node 内部提供了 Module 构建函数。所有模块都是Module 的实例。 123456function Module(id,parent)&#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ...&#125; module 的属性： id : 模块识别符，带有绝对路径的模块文件名； filename: 模块文件名，带有绝对路径； loaded : 布尔值，模块是否加载完成； parent ： module 对象，引用本模块的模块； children : module 数组， 本模块引用的其他模块； exports ：对象，本模块的导出值是其属性。 没被其他模块引用的模块通常是程序入口，此时 parent 属性是为 null，可根据该特性判断是否为程序入口。 123456789if (!module.parent) &#123; // ran with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // used with `require('/.something.js')` module.exports = app;&#125; exports 变量 为了方便，node 为每个模块提供了 exports 变量，指向 module.exports，即 1let exports = module.exports 可向 exports对象加添加属性和方法。 123exports.area = function(r)&#123; return Math.PI*r*r;&#125; 不能直接将exports变量指向一个值，因为这样等于切断了exports = module.exports的联系 一个模块的对外接口，是一个单一的值（一个函数或者一个变量），不能使用 exports 输出，只能使用module.exports输出。 —————————————————————————————————————— 在exports上添加属性，再导出，导出的是一个对象。 exports.prop = value 等同于 module.exports = {prop:value} 123//example.1.js 在exports添加属性let print = (value) =&gt;console.log(value);exports.print = print; 123//example.2.js 将单一的值赋值给 module.exportslet print = (value) =&gt; console.log(value);module.exports = print; 123//example.3.js 将单一的值赋值给let print = (value) =&gt; console.log(value);exports = print; 1234567//test.jslet example1 = require('./example.1');let example2 = require('./example.2');let example3 = require('./example.3');console.log(example1);// &#123; print: [Function: print] &#125;console.log(example2);// [Function:print]console.log(example3);// &#123;&#125; 给 exports 赋值只能导出空对象 为了简化，只用 module.exports导出值。 require 命令 require的基本功能是：读取并执行一个模块，返回该模块的 exports对象，可用解构赋值的方式提取部分属性，没有发现模块，报错。 加载规则 参数以 /开头，加载绝对路径下的模块； 参数以 ./开头，加载当前目录下的模块； 不以 ./或 /开头，加载核心模块或依次在各级 node_modules目录的查找； 想得到包含文件名的完整路径，使用 require.resolve()。 目录的加载规则 通常把相关文件放在一个目录下，便于组织。这时最好为目录设置一个入口文件，require方法能根据这个文件，加载整个目录。 在目录中设置一个 package.json，写入 main字段。 package.json 文件由 npm init命令生成，npm init -y 可不用一一回答询问，直接采用默认值，再手动修改。 12345//package.json&#123;"name":"some-library","main":"./lib/some-library.js"&#125; require发现参数为一个目录，会先查找该目录下的 package.json文件，加载 main字段指定的入口文件。没有 main字段或者没有package.json文件，则加载该目录下的 index.js文件或者index.node。 node 模块分类 核心模块，内置在 node 内部的，直接引用即可。 第三方模块 用 npm 下载，安装到程序目录的 node_modules文件夹中； 模块加载时，会先在核心模块中搜索，再到程序的node_modules文件夹中搜索。 文件模块 文件夹模块 按照目录加载机制加载。 模块的缓存 第一次加载，以后从缓存中读取module.exports属性。 所有模块的缓存都保存在 require.cache中。 删除模块缓存： 12345// 删除指定模块缓存delete require.cache(moduleName)// 删除所有模块缓存Object.keys(require.cache).forEach(key=&gt;&#123;delete require.cache[key]&#125;) require.main main属性，可用来判断是直接执行还是调用执行。直接执行： node module.js，require.main属性指向模块本身。 12//直接执行 表达式为 truerequire.main === module 通过 require加载模块执行，上面的表达式为false 模块加载机制 模块一旦输出值，模块内部的变化，影响不到这个输出值。 1234567891011// lib.jslet counter = 3;let incCounter = () =&gt; &#123; counter++ console.log('模块内部',counter);&#125;console.log('lib', require.main === module);// 被require 执行，输出 falsemodule.exports = &#123; counter, incCounter,&#125; 12345678// test.1.jslet counter = require('./lib').counterlet incCounter = require('./lib').incCounterconsole.log('模块外部', counter);//3 incCounter();// 模块内部的值改变为 4 console.log('模块外部', counter);//外部的值 还是为3 console.log('test', require.main === module);// 直接执行，输出 true 最后输出： 12345lib false模块外部 3模块内部 4模块外部 3test true 参考文章 CommonJS规范 前端模块化（一）nodeJS中的CommonJS规范]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>commonJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5 websocket]]></title>
    <url>%2F2019%2F06%2F16%2Fhtml5-websocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行的全双工通信协议。 具体使用 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务器主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需一次HTTP握手，就建立了持久连接，后续可双向通信。 没有出现 websocket 之前，服务器实现推送消息，一般都是 通过 AJAX 轮询，这种方式浪费带宽，频繁的连接、断开，消耗服务器资源。 建立 websocket 连接后，可主动向对方发送数据，通过 onmessage 事件来接收数据。 创建 webSocket 对象： 1let Socket = new WebSoket(url[,protocol]);// url: 可以是 wss 和 ws 协议。 websocket 使用的默认端口和TCP相同，默认80，wss，默认443。 protocol： 哪些子协议常用呢？ 一个客户端请求例子： 12345678GET / HTTP/1.1Upgrade: websocket //希望升级到 websocket 协议Connection: Upgrade //表示升级通信协议Host: example.comOrigin: http://example.comSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==Sec-WebSocket-Version: 13 //webSocket 版本 Sec-WebSocket-Key：一个随机字符串，服务器会使用这个数据构造出一个SHA-1的信息摘要。Sec-WebSocket-Key 加上一个特殊字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后计算摘要，再进行base-64编码，将结果作为响应头Sec-WebSocket-Accep的值，这样做的目的是，尽量避免http请求被误认为是websocket协议。 Origin：可选字段，表示发情websocket连接的页面，类似Referer，但是 Origin 包含子协议和主机名。 响应： 123456HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Location: ws://example.com/ websocket 属性： 属性 值 说明 对应属性 readyState（只读） 0 连接正在建立 连接正在建立 readyState 1 连接已建立，可通信 OPEN readyState 2 连接正在关闭 CLOSEING readyState 3 连接已关闭或者连接无法打开 CLOSED bufferedAmount（只读） 数值 正在等待传输的数据的字节数 可用来判断发送是否完毕 如何监听 readyState 的状态变化呢？ 事件： 属性 处理程序 说明 open onopen 建立连接时触发 error onerror 通信发生错误时触发 message onmessage 接收到数据时触发 close onclose 连接关闭时触发 以上事件的事件处理函数的参数都是事件event,可在事件中获取相关信息。 方法： 方法 说明 参数 send 发送数据 参数只能是字符串或者二进制 close 关闭连接 无参数 二进制数据可用blod或者ArrayBuffer 12345678910ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log("Received data string"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log("Received arraybuffer"); &#125;&#125; 还可指定接收的类型： 1234567891011ws.binaryType = "blob"; // 指定接收的二进制数据的类型ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = "arraybuffer";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; 参考 全双工的 websocket]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种重定向]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%87%A0%E7%A7%8D%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[几种重定向 总结几种重定向的区别。 [TOC] 307 Temporary Redirect(临时重定向) 通过响应头字段Location告诉浏览器资源暂时移动到别处，原来的方法和消息被用用来先新的URL发送请求。 307和302之间的唯一区别在于307该方法和主体将不会被重定向的请求时改变保证。使用302，一些老客户错误地将方法改变为GET：使用非GET方法的行为，然后302在Web上不可预知，而使用307的行为则是可预测的。对于GET请求，它们的行为是相同的。 301 Moved Permanently（永久移动） 资源已明确移动到Location标题给定的URL。浏览器重定向到这个页面，搜索引擎更新它们到资源的链接。规范要求方法和主体在执行重定向时不会被更改，但并非所有浏览器都与它一致。推荐301仅作为响应GET或HEAD方法，在其他方法下使用301,必须向用户询问是否重定向。 对于GET方法，chrome 和火狐浏览器，会使用GET再次向Location地址发起请求，但是远程IP却是原来的,响应状态码为301，其他请求头信息两者不仅相同。 可使用308代替301，因为 308 下明确禁止更改请求方法。会使用GET再次向Location地址发起请求，但是远程IP却是原来的,狐火的响应状态是 Connection Established，chrome 是301,其他头信息也有差别。 302 Found（找到） 资源已明确移动到Location标题给定的URL。浏览器重定向到这个页面，搜索引擎不会更新它们到资源的链接。规范要求方法和主体在执行重定向时不会被更改，但并非所有浏览器都与它一致。建议设置302代码仅作为一个响应GET或HEAD方法和想要明确禁止更改方法，使用307 Temporary Redirect代替。 想要改变方法的情况下，改为GET使用303 See Also，这样如果你想给PUT请求一个确认信息，改了303就很有用了。 303 See Other（见其他） HTTP 303 See Other重定向状态响应代码（通常作为一个 PUT或POST操作的结果发回）表示重定向不链接到新上载的资源，而是链接到其他页面，如确认页面或上载进度页面。用于显示此重定向页面的方法始终是GET。 重定向]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xhr 全面总结]]></title>
    <url>%2F2019%2F06%2F16%2Fxhr-%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AJAX(Asynchronous JavaScript Xml)，异步的JS xml，以前客户端和服务器 通信，一般传递 xml，但是现在传递 JSON为主，ajax 能实现页面部分更新，使得页面性能高和体验良好。AJAX 是一种向服务器发送 HTTP 请求，实现与服务器交互的技术，已经是HTTP请的代名词，但是不只支持 http 协议，还支持 ftp、file协议。 一级xhr 二级 xhr 一级xhr或者老版本的xhr，有一些缺点： 只支持文本数据传输 无法读取和上传二进制文件 只用成功、失败、完成等状态，没进度信息 不能跨域 二级xhr，改进了这些问题： 可设置超时 formData 对象管理表单数据 文件上传 可跨域 可获取二进制文件 可获取传输进度 XMLHttpRequest 对象 ajax 技术的核心是 XMLHttpRequest 对象，简称XHR，现在较为先进的浏览器都支持（低版本的IE可滚粗了）创建 xhr 对象，new 一个即可。 1var xhr = new XMLHttpRequest(); xhr 的用法 通常步骤： 第一步：var xhr = new XMLHttpRequest()—创建 xhr; 第二步：xhr.open(METHOD,URL,isAsync)—启动xhr; 第三步：xhr.responseType = reposnseType—设置返回值类型，默认 '',必须在返回值达到客户端前设置; 第四步：xhr.onreadystatechange=handleFun—监听请求状态变化； 第五步：xhr.setRequestHeader('Content-Type','application/json;charset=utf-8')—设置请求头，不需要设置，可省略，必须在请求开启和发送之间设置; 第六步：xhr.send(data)—发送请求。 完整的例子： 12345678910111213141516var http = new XMLHttpRequest();http.open('GET','/endpoint',true);http.responseType = 'json';http.onreaydstatechange = function()&#123; if(http.readyState === 4)&#123; if(http.status === 200)&#123; console.log(http.response); &#125;else&#123; console.error(http.response); &#125; &#125;&#125;;http.onerror = function()&#123; console.error(http.statusText);&#125;http.send(null); 实例属性 readyState 只读属性，是一个数字，表示此时的 HTTP 请求状态。 值 状态 其他 0 xhr创建，open方法还未调用 1 open已调用，send未调用，此时可设置请求头 2 send已调用，且服务器返回的头信息和状态码已经收到 3 正在接收响应body，收到部分信息。 4 已收到服务返回即请求完成，可能失败，可能成功 0 UNSENT open() has not been called yet. 1 OPENED send() has been called. 2 HEADERS_RECEIVED send() has been called, and headers and status are available. 3 LOADING Downloading; responseText holds partial data. 4 DONE The operation is complete. 每当 xhr的状态发生变化，readyState属性就发生变化，就会触发readyStateChange事件，所以可在 readyStateChange 事件的监听函数里处理返回的请求信息。 onreadystatechange 事件，指向一个函数。执行abort方法，也会改变 readyState。 response 服务器返回的数据，只读，类型由 responseType决定。请求不成功或者数据不完整，值为 null。 responeType 可写属性，指定响应格式，在 open之后send之前，设置返回的数据类型。 值 说明 ‘’(空字符串) 默认值，等同于text,适用大多数情况。只是设置该值时，才可获取responseText json 浏览器会自动调用JSON.parse解析JSON字符串，此时response是一个对象，不是字符串 blob Blob对象，二进制对象，请求图片，下载文件等 document Document 对象，文档对象，HTML/XML文档对象等，收到返回值后不用解析HTML字符串，直接进行DOM操作 arraybuffer ArrayBuffer对象,二进制数组 responseText 返回值类型是String，可用这个属性获取。也就是说 responseType设置text或者''，response和responseText是相同的。 responseXML 返回值时 HMTL 或者 XML 对象，可用该属性获取，只读。该属性生效的前提是，响应头信息 Content-Type为 text/xml或者application/xml,这要求，发送请求前，将responseType设置为document。如果响应头信息 Content-Type不为 text/xml或者application/xml，就需要手动调用overrideMimeType('text/xml')，强制进行XML解析。 123456789var http = new XMLHttpRequest();http.open('GET','/',true);http.responseType = 'document';http.onload = function()&#123; if(http.reaydState === 4 &amp;&amp; http.status === 200)&#123; console.log(http.responseXML); &#125;&#125;http.send(null); responseURL 只读，返回数据的服务器的url。和 open 里的 url 不一定相同，不含锚点。 status statusText status一个整数，表示 HTTP 的状态码，只读，发出请求前，为 0。 statusText是状态信息，只读，无返回状态信息，默认 OK。 status statusText 状态 200 OK 成功返回 301 Moved Permanently 永久移动 302 Moved Temporarily 暂时移动 304 Not Modified 未修改 307 Temporary Redirect 暂时重定向 400 Bad request 无效请求 401 Unauthorized 未授权 403 Forbindden 禁止访问 404 Not Found 未找到 405 Method not allowed 方法不被允许 500 Internal server error 服务器内部出错 503 Service unavailable 服务不可用 基本上 2xx和 304，返回正常。 1234567if(http.readyState ===4 )&#123; if((http.status &gt;= 200 &amp;&amp; http.status &lt; 300)||(http.status === 304))&#123; //处理返回数据 &#125;else&#123; //返回出错 &#125;&#125; timeout ontimeout timeout属性是一个整数，表示多少毫秒后，如果请求还未返回，就会自动终止。触发timeout事件， 为 0 ，表示无时间限制，不是整数，会先转换，成数字，转换失败，则不生效。 ontimeout指向一个函数，timeout触发，就执行该函数。 1234567891011121314var http = new XMLHttpRequest();http.ontimeout = function()&#123; console.log('请求超时');&#125;http.onload = function()&#123; if(http.readyState === 4 &amp;&amp; http.status === 200)&#123; //正常返回 &#125;else&#123; console.log(http.statusText); &#125;&#125;http.open('GET','/users/12132',true);http.timeout = 1000*10;// 10 秒超时http.send(null); withCredentials 一个布尔值，表示跨域请求时，用户信息（Cookie、认证的 http 头信息）是否会包含在请求中，默认false。同源请求不需要设置。为了使得该属性生效，必须返回头信息 Access-Control-Allow-Credentials且值为 true。 打开了，跨域会发送 cookie，还会设置Cookie。 upload 用 AJAX 发送文件 xhr 不仅可以发送请求，还可发送送文件。发送文件后，upload属性可得到一个对象，通过该对象，可监听该对象的各个事件得到上传状态。 显示上传进度： 1&lt;progress min="0" max="100" value="0"&gt;0% complete&lt;/progress&gt; 监听upload对象的progress事件，可得到上传进度： 123456789101112131415function uploadFile(&#123;blodOrFile=null,type='json'&#125;)&#123; var http = new XMLHttpRequest(); http.open('POST','/srever',true); http.onload = function()&#123;&#125;; var progressBar = document.querySelector('progress'); http.upload.onprogress = function(event)&#123; if(event.lengthComputable)&#123; progressBar.value = (event.load / event.total)*100; // 兼容老式浏览器 progressBar.textContent = progressBar.value; &#125; &#125; http.send(blodOrFile);&#125;uploadFile(&#123;blodOrFile:new Blod(['hello ajax'])&#125;) 事件属性 可监听 xhr 的以下事件：书写顺序为触发顺序，监听这些事件，必须在send之前进行 属性 事件 何时触发 onloadstart loadstart 请求发出,在 readyState == 1 和 readyState == 2之间,onloadstart 默认传入 progressEvent 对象 onprogress progress 正在发送或者加载返回的数据,onprogress 默认传入progressEvent对象 onabort abort 终止请求，比如调用abort，调用该方法，readyState 被设置为 0 onerror error 请求失败 ontimeout timeout 请求超时 onload load 请求成功，以上四个事件互斥，触发0次或者1次 onloadend loadend 请求完成,可能成功，可能失败。abort、load、timeout、readtState=4都会伴随着loadend,onloadend 默认传入 progressEvent 对象 onreadystatechange readystatechange xhr状态，监听该事件，可得知请求是否完成，这个属性时xhr特有的，其他属性时xhr.upload和xhr共有的 123456789101112131415161718192021http.onload = function() &#123; var responseText = xhr.responseText; console.log(responseText); // process the response.&#125;;http.onabort = function () &#123; console.log('The request was aborted');&#125;;// `只有 onprogress 有一个事件参数`http.onprogress = function (event) &#123; console.log(event.loaded);//已返回的数据量 console.log(event.total);//返回的总数据量 console.log(event.lengthComputable);//加载进度是否可计算&#125;;function handleError() &#123; console.log('There was an error!');&#125;;http.addEventListener('error', handleError); onload vs onreadyStateChange 处理返回值，是在 onload还是在onreadyStateChange? onload 等于 readyState==4 &amp;&amp; xhr.status===200 loadend 事件的触发： 123456onreadystatechange readyState === 4 ⇓onload / onerror / onabort ⇓ onloadend 使用 onerror并且不考虑老式浏览器，推荐用 onload而不用onreadySateChange。 实例方法 open 在open方法中指定请求参数，返回值为undefined。 opend(METHOD,URL,isAsync,user,password),user 和 password 可选，统一请求，再次用open，就等同于调用abort。一般 URL 需要用 encodeURI或encodeURICompent编码。 GET 请求绕过缓存 GET 请求会缓存，在 url 后面加时间戳可绕过缓存。 123456http://foo.com/bar.html -&gt; http://foo.com/bar.html?12345http://foo.com/bar.html?foobar=baz -&gt; http://foo.com/bar.html?foobar=baz&amp;12345var oReq = new XMLHttpRequest();oReq.open("GET", url + ((/\?/).test(url) ? "&amp;" : "?") + (new Date()).getTime());oReq.send(null); send send 用于发送数据，可发发送多种类型的数据。 String、Bold、Document、Formdata、ArrayBuffer、null。 发送表单数据： 123456&lt;form id='registration' name='registration' action='/register'&gt; &lt;input type='text' name='username' value='张三'&gt; &lt;input type='email' name='email' value='zhangsan@example.com'&gt; &lt;input type='number' name='birthDate' value='1940'&gt; &lt;input type='submit' onclick='return sendForm(this.form);'&gt;&lt;/form&gt; 12345678910111213141516function sendForm(form) &#123; var formData = new FormData(form);//对表单进行加工 formData.append('csrf', 'e69a18d7db1286040586e6da1950128c'); var xhr = new XMLHttpRequest(); xhr.open('POST', form.action, true); xhr.onload = function() &#123; // ... &#125;; xhr.send(formData);//发送 return false;&#125;var form = document.querySelector('#registration');sendForm(form); setRequestHeader(filed,value) 设置请求头信息，open 之后，send 之前调用。 overrideMimeType() 重新设置服务器返回的数据类型，必须在 send 之前调用。 getResponseHeader(filed):String 获取某个响应头信息，参数不区分大小写。 getResponseHeaders():String 获取所有响应头信息，每个头信息之间用 \r\n(换行)分割。 1234567891011date: Fri, 08 Dec 2017 21:04:30 GMT\r\ncontent-encoding: gzip\r\nx-content-type-options: nosniff\r\nserver: meinheld/0.6.1\r\nx-frame-options: DENY\r\ncontent-type: text/html; charset=utf-8\r\nconnection: keep-alive\r\nstrict-transport-security: max-age=63072000\r\nvary: Cookie, Accept-Encoding\r\ncontent-length: 6502\r\nx-xss-protection: 1; mode=block\r\n 处理头信息： 1234567891011var arr = headers.trim().split(/[\r\n]+/);var headerMap = &#123;&#125;;arr.forEach(function (line) &#123; var parts = line.split(': ');//注意 '' var header = parts.shift();//删除第一个元素，原数组改变，随便获取到 头字段。一举两得，妙 var value = parts.join(': ');//\r\n 去哪儿了 headerMap[header] = value;&#125;);headerMap['content-length'] // "6502" abort 终止请求，使得 readyState为 4，status为 0。 页面卸载时发送数据 在页面卸载时发送数据，即在unload或者beforeunload的监听函数里，发送AJAX，但是不可靠。xhr 是异步的，可能在发送数据时，页面就卸载了，可打发送失败，那么用同步发送，但是同步发送数据，很多浏览器不支持，同步发送，用户体验不好。 用 Navigator.sendBeacon(url,data)，该方法与当前页面脱钩，作为浏览器任务，能保证把数据发出去。data 可以是字符串、表单对象、二进制对象等，返回 布尔值，true 说明发送成功，可跨域，POST，比较多的先进浏览器支持。 请求头信息 Content-Type根据发送的 data 类型设置，且不能设置其他头字段。 data Content-Type Blod Blod formData multipart/form-data String text/plain 12// HTML 代码如下&lt;body onload="analytics('start')" onunload="analytics('end')"&gt; JS: 123456function analytics(state) &#123; if (!navigator.sendBeacon) return; var URL = 'http://example.com/analytics'; var data = 'state=' + state + '&amp;location=' + window.location; navigator.sendBeacon(URL, data);&#125; 123var headers = &#123;type: 'application/json'&#125;;var blob = new Blob(request, headers);navigator.sendBeacon('url/to/send', blob); 关于 formData 对象 xhr2 提供了 FormData 对象，为表单序列化和创建与表单相同的数据提供了便利。 其主要用于发送表单数据，也可构造与表单相同的数据，还可以发送文件。 formdata 发送表单 123var formData = new FormData();//创建 formData 对象formData.append('name','jack');//添加表单项xhr.send(formData); 1234567891011121314151617181920212223242526&lt;form id="user-info"&gt; &lt;label for="user-name"&gt;姓名:&lt;/label&gt; &lt;input type="text" id="user-name" name="user-name" /&gt;&lt;br&gt; &lt;label for="user-email"&gt;Email:&lt;/label&gt; &lt;input type="text" id="user-email" name="user-email" /&gt;&lt;br&gt; &lt;input type="button" value="Submit" onclick="submitData()" /&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; function submitData() &#123; var http = new XMLHttpRequest(); http.open("post", "formdata", true); http.onreadystatechange = function (event) &#123; if (http.readyState == 4) &#123; if (http.status == 200) &#123; console.log(http.responseText); &#125; else &#123; alert("Request was unsuccessful: " + http.status); &#125; &#125; &#125;; var form = document.getElementById("user-info"); var formdata = new FormData(form);//用表单初始化一个 FormData 对象 formdata.append('额外字段', 123);//字段值不是字符串，会转为字符串 http.send(formdata); &#125; &lt;/script&gt; 请求头信息： 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryoCpZL9koEpmlasTW 请求体信息： 12345678910111213------WebKitFormBoundaryoCpZL9koEpmlasTWContent-Disposition: form-data; name="user-name"afafa------WebKitFormBoundaryoCpZL9koEpmlasTWContent-Disposition: form-data; name="user-email"afafa@163.com------WebKitFormBoundaryoCpZL9koEpmlasTWContent-Disposition: form-data; name="额外字段"123------WebKitFormBoundaryoCpZL9koEpmlasTW-- 和表单enctype=&quot;multipart/form-data&quot;提交一样的。 用 express 处理提交，服务端： 12345678910/** * formData 上传表单 * bodyParser 不能处理 formData 数据，需要额外的中间件 */let multer = require('multer');let upload = multer();app.post("/formdata", upload.fields([]), (req, res) =&gt; &#123; console.log(req['body']); res.json(&#123; success: true &#125;);&#125;); formdata 上传文件 TODO 如何用 express 接收呢？ 客户端： 123456789&lt;form enctype="multipart/form-data" method="post" name="fileinfo"&gt; &lt;label&gt;Your email address:&lt;/label&gt; &lt;input type="email" autocomplete="on" autofocus name="userid" placeholder="email" required size="32" maxlength="64" /&gt;&lt;br /&gt; &lt;label&gt;Custom file label:&lt;/label&gt; &lt;input type="text" name="filelabel" size="12" maxlength="32" /&gt;&lt;br /&gt; &lt;label&gt;File to stash:&lt;/label&gt; &lt;input type="file" name="file" required /&gt; &lt;input type="submit" value="Stash the file!" /&gt; &lt;/form&gt; 待完成 formData 对象 浏览器 Blod arrayBuffer xhr 封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * options = &#123; url 提交请求的url method 请求的类型，默认为GET data 请求体的数据 cache 是否缓存数据，默认为false async 是否以异步方式进行，默认为true success 成功后的处理方法 error 失败后的处理方法 &#125; */function ajax(options) &#123; var options = options || &#123;&#125;; options.method = options.method.toUpperCase() || 'GET'; options.async = options.async || true; options.cache = options.cache || true; // 格式化参数的函数 var getParams = function (data) &#123; var arr = []; for (param in data) &#123; //查询字符串中每个参数的名称和值都必须使用 encodeURIComponent()进行编码 arr.push(encodeURIComponent(param) + "=" + encodeURIComponent(data[param])); &#125; // 在 url 末尾加上一个随机数，避免相同值使用 IE 缓存 if (options['cache']) &#123; arr.push(("randomNum=" + Math.random()).replace(".", "")); &#125; // 返回带有 &amp; 的查询字符串 return arr.join("&amp;"); &#125; var params = getParams(options['data']); var http = new XMLHttpRequest(); http.onload = function () &#123; if (http.status === 200 || http.status === 304) &#123; // 成功 options.success &amp;&amp; options.success(http.response); &#125; else &#123; // 失败 options.fail &amp;&amp; options.fail(http.status); &#125; &#125; switch (options['method']) &#123; case 'GET': http.open("GET", options['url'] + "?" + params, options['async']); // 发送请求 http.send(null); break; case 'POST': http.open('POST', options['url'], options['async']); http.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); http.send(params) break; default: console.log('不支持的方法'); //TODO: 如何支持其他方法？ break; &#125;&#125; promise 版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function http(&#123; url = '', method = 'get', data = &#123;&#125;, dataType = 'multipart', responseType = 'json', headers = &#123;&#125;,&#125; = &#123;&#125;) &#123; let body = null; method = method.toUpperCase(); if (!url) &#123; console.error('url是必需参数！'); return; &#125; function xhr(resolve, reject) &#123; let http = new XMLHttpRequest(); http.responseType = responseType; http.onload = function() &#123; if (200 == http.status || 304 === http.status) &#123; resolve(http.response); &#125; else &#123; reject(http.statusText); &#125; &#125;; http.onerror = function(e) &#123; reject(e); &#125;; switch (method.toLowerCase()) &#123; case 'get': var queryString = ''; if (JSON.stringify(data) !== '&#123;&#125;') &#123; queryString = Object.keys(data) .map(function(key) &#123; return encodeURIComponent(key) + '=' + encodeURIComponent(data[key]); &#125;) .join('&amp;'); &#125; if (queryString) &#123; url += '?' + queryString; &#125; http.open('GET', url, true); break; case 'post': http.open('POST', url, true); if ('json' === dataType) &#123; body = JSON.stringify(data); http.setRequestHeader('content-type', 'application/json;charset=UTF-8'); &#125; else if ('urlencoded' === dataType) &#123; body = Object.keys(data) .map(function(key) &#123; return encodeURIComponent(key) + '=' + encodeURIComponent(data[key]); &#125;) .join('&amp;'); http.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); &#125; else if ('xml' === dataType) &#123; http.setRequestHeader('content-type', 'text/xml'); &#125; else &#123; body = data; &#125; break; &#125; for (const [key, value] of Object.entries(headers)) &#123; http.setRequestHeader(key, value); &#125; http.send(body); &#125; let promise = new Promise(xhr); return promise;&#125; 参考 XMLHttpRequest 对象 - JavaScript 教程 - 网道 Navigator.sendBeacon() to pass header information Is onload equal to readyState==4 in XMLHttpRequest? What is meaning of xhr.readystate===4 Why Use onload in Cross-domain Ajax XMLHttpRequest Living Standard — Last Updated 28 November 2018]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>xhr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web worker 实现浏览器多线程]]></title>
    <url>%2F2019%2F06%2F15%2Fweb-worker-%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS 天然属于单线程环境，也就是说不能同时运行多个脚本。为何这样？因为JS的设计目标是实现网页和用户交互，试想当用户点击页面，操作 DOM 时，有两个线程同时操作了DOM，那么以谁的结果为准呢？最坏的情况一个线程需要给一个元素添加内容，另一个线程却把元素删除了，这将导致用户无法和页面交互。这就是JS只能单线程的原因，所有任务都在一个线程上执行，不必考虑多线程的问题。JS 需要同时执行两个任务的地方，可通过定时器、事件处理器等异步技术实现并行（其实依然单线程）。HTML5 引入 web worker 实现真正的多线程。通过 Web Worker 在后台执行一些操作，例如触发长时间运行的脚本以处理计算密集型任务，同时却不会阻碍 UI 或其他脚本处理用户互动。 Worker 利用类似线程的消息传递实现并行。这非常适合您确保对 UI 的刷新、性能以及对用户的响应。 web worker 的类型 两种类型： 专用 worker（Dedicated workers）：只能在创建它的脚本中使用； 共享 worker（Shared workers）：可在多个脚本中使用。 worker 和主线程之间通信通过消息机制进行–使用postMessage 函数向对方传递数据，对方通过监听message事件获取并处理数据。数据不是共享，而是复制。所以传递对象时，可以操作该对象，而不会影响另一个线程中的对象。 worker 和主线程的脚本必须同源，简单理解成同一个网站加载到浏览中。 专用 worker worker 特性检测 在主线程检测浏览器是否支持 worker,在决定是否创建 worker。 123if(window.worker)&#123; //do something&#125; 目前主要浏览器都支持。更多详情 使用入门 web worker 在独立线程中运行，可将其代码保存在一个单独的JS文件中，然后在创建 worker 时引入该脚本。很多浏览器还不支持本地文件运行worker，我们需要结合服务器时间。可使用 express 创建一个服务器。 在 public/javascripts 文件夹在创建 worker.js： 12345678910this.addEventListener('message', (event) =&gt; &#123; console.log(this) console.log(event) console.log(event.data) console.log(event.origin) console.log(event.ports) console.log(event.source) console.log(event.lastEventId) self.postMessage(&#123; name: 'worker.js', data: 'hello,main.js!' &#125;)&#125;, false) 这就是 worker 线程的代码。 在页面的 JS 代码中创建 worker，为了简单起见，在script 标签中写脚本： 123456789101112&lt;script&gt;let worker = new Worker('/javascripts/worker.js');//创建一个 workerlet workerButton = document.getElementByI('workerButton'); workerButton.addEventListener('click', (event)=&gt; &#123; console.log(event) worker.postMessage(&#123; name: 'main.js', data:'hello,worker.js!' &#125;);//向 worker 线程发送消息 &#125;, false) // 监听 worker 线程发送过来的消息 worker.addEventListener('message', (event) =&gt; &#123; console.log(event.data); &#125;, false)&lt;/script&gt; 创建 worker 时指定的脚本是异步加载的，如果加载成功，会生成一个 worker 线程。完全加载和执行之前，系统不好生成 worker。如果脚本不存在，返回404，创建 worker失败。 postMessage 用来启动 worker，也用来发送消息。 停止 worker 在主线程中，通过worker.terminate() 停止 worker;在worker 线程中，使用close()来停止worker。 12345let stopWorker = document.getElementById('stopWorker');stopWorker.addEventListener('click', () =&gt; &#123; let result = worker.terminate(); console.log(result);&#125;, false); worker 自己停止： 在主线程中通知worker停止： 12345let stopWorker = document.getElementById('stopWorker');stopWorker.addEventListener('click', () =&gt; &#123; let result = worker.postMessage('stop'); console.log(result);//undefined&#125;, false) worker.js 1234567891011121314this.addEventListener('message', (event) =&gt; &#123; console.log(this) console.log(event) console.log(event.data) console.log(event.origin) console.log('cache',this.cache) console.log(event.source) console.log(event.lastEventId) if ('stop' === event.data) &#123; let result = this.close(); console.log('worker stop ',result);//undefined &#125; self.postMessage(&#123; name: 'worker.js', data: 'hello,main.js!' &#125;)&#125;, false) worker 环境 worker 作用域：在worker脚本文件内，this 和 self 都是全局作用域。上面的console.log(this)的输出是： 1DedicatedWorkerGlobalScope。 worker 线程中并不能完成使用主线程的功能，只能使用部分JS功能： navigator 对象； location 对象； XMLHttpRequest 对象； 定时器； 应用缓存； importScripts(); 生成其他 worker。 worker 中无法使用： DOM(非线程安全)； window 对象； document 对象； parent 对象。 我们在 worker.js 发发送一个http 请求，拿到返回值后传递给主线程： 12 更多详细情况 加载外 worker 脚本 可使用importScripts 函数加载外部的脚本进入 worker 脚本执行。 在 worker.js 记载一个脚本： 1importScripts('./importTest.js');// 可传递多个路径，路径是相对于 worker.js 的 importTest.js 12345test(5)function test(time) &#123; setInterval(() =&gt; &#123; console.log('你好'); &#125;, 1000 * time); worker 线程停止后，加载的外部脚本也停止执行。 错误处理 可在主线程中处理 worker 线程的错误，在主线程中监听 worker 的 错误事件： 12345worker.addEventListener('error', (event) =&gt; &#123; console.log(event.colno); console.log(event.filename); console.log(event.message);&#125;, false); 输出该错误事件，可看到事件的一些属性： 不冒泡、可取消等，具有普通事件的一些属性。 worker 生成一个错误： 12345678this.addEventListener('message', (event) =&gt; &#123; if ('stop' === event.data) &#123; let result = this.close(); console.log('worker stop ', result); &#125; self.postMessage(&#123; name: 'worker.js', data: 'hello,main.js!' &#125;) this.postMessage(new Error('制造一个错误！'));&#125;, false) 内嵌 worker 上面的例子，将 worker 代码放在单独的文件里，这样便于管理代码，也方便修改，因为有语法高亮，可以将 worker 代码放在和主线程相关的html文件里: 1234567891011121314151617181920212223&lt;script id="worker" type="javascript/worker"&gt; this.addEventListener('message', (event) =&gt; &#123; if ('stop' === event.data) &#123; this.close(); &#125; console.log(event.data); self.postMessage(&#123; name: 'worker.js', data: 'hello,main.js!' &#125;); &#125;, false); &lt;/script&gt; &lt;script&gt; let workerContent = document.getElementById('worker').textContent; let blob = new Blob([workerContent], &#123; type: 'text/javacript' &#125;); let url = URL.createObjectURL(blob); console.log(url); let worker = new Worker(url); worker.addEventListener('message', (event) =&gt; &#123; console.log(event.data); &#125;); let workerButton = document.querySelector('#workerButton'); workerButton.addEventListener('click', (event) =&gt; &#123; worker.postMessage(&#123; name: "主线程" &#125;); &#125;, false); &lt;/script&gt; 将 worker 的代码在 script 标签中，声明类型为javascript/worker,就不会被浏览器解析成JS代码，而是当成普通的 html 标签，可通过DOM api 获取标签内的文本，创建 worker。 使用 Blob 生成一个blob 对象，再使用 URL.createObjectURL成连接，再生成 worker。 1234let blob = new Blob([workerContent], &#123; type: 'text/javacript' &#125;);let url = URL.createObjectURL(blob);console.log(url);let worker = new Worker(url); 关于Blob 关于Blob和URL worker 的使用场景 常用的场景： 预先抓取和/或缓存数据以便稍后使用； 突出显示代码语法或其他实时文本格式； 拼写检查程序； 分析视频或音频数据； 背景 I/O 或网络服务轮询； 处理较大数组或超大 JSON 响应； &lt;canvas&gt; 中的图片过滤； 更新本地网络数据库中的多行内容。 更多参考 Web Workers 的基本信息 使用 Web Workers worker读取文件]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fetch API 入门使用]]></title>
    <url>%2F2019%2F06%2F09%2FFetch-API-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[html5 引入了新的网络请求接口Fetch API，原生支持Promise，可配合 async/await 语法使用。 Fetch 实例 使用 fetch 用户数据列表。 1234fetch('/users').then(res=&gt;res.json())//服务器返回的是json.then(user=&gt;&#123;console.log(user);&#125;).catch(error=&gt;&#123;console.log(error);&#125;) async/await 语法 123456789async function getUsers() &#123; try &#123; let res = await fetch('/users'); let users = await res.json(); console.log(users) &#125; catch (error) &#123; console.log(error) &#125;&#125; fetch 返回的不是真正需要的数据，而是一个 Promise，所有还需要使用它提供的方法进一步获取想要的数据。 具体用法 两种调用方式： 12fetch(url,options)fetch(req,options) 推荐使用第一种，一眼就可以看到url,更加直观。 options 是一个对象，可设置以下字段： method：请求方法，默认GET; headers：请头信息，可以是简单的对象，也可以是 Headers 的实例； body：发送数据。Blod、bufferSource、FormData、URLSearchParams、USVstring，GET、HEAD 没有body； mode：请求模式。 cors：跨域请求； no-cors：只允许使用GET、HEAD、POST; same-origin：同源请求； navigate：支持页面导航（不太明白）。 credentials：是否发送 cookies： omit：不发送，默认； same-origin：同源发送； include：发送。 cache：缓存策略： default：请求之前检查缓存； no-cache：有缓存，发送一个查询请求，缓存失效，再发送正常请求； no-store：不检查缓存，直接请求； reload：忽略缓存，拿到响应后，更新缓存； force-cache：强制读取缓存，缓存过期，再发送正常请求； only-if-cached：读取缓存，过期就报网络错误。 mode 设置为 same-origin 时有效。 redirect：重定向时的处理方法： follow：跟随； error：报错； manual：用户手动跟随。 integrity：包含一个验证资源完整性的字符串。 Headers Headers 用于构造请求头信息，构造函数接收一个对象，对象的key-value就是请求头的信息。 123456789101112let headers = new Headers( &#123; 'content-type':'text/plain', 'content-length':data.toString().length &#125;);headers.append('X-Custom-header','AnotherValue');//追加headers.has('content-type');//true 查询headers.get('content-type');//'text/plain' 获取// headers.getAll('content-type');//['text/plain'] getAll 被移除了headers.delete('content-type');//删除headers.set('content-type','json');//重写 Request 请求对象。可以新建一个，也可以从已有的对象中继承。 1234let Url = '/users';let req = new Request(Url,&#123;method:'GET',headers&#125;)// 扩展 requestlet postReq= new Requset(req,&#123;method:'POST'&#125;) Response Response 实例是 fertch 处理完 promise 之后的返回的。也可以手动创建，在servoceWorkers 中才真实有用。 1let res = new Response(body,init) body 可以是Bolb、BufferSource、FormData、URLSearchParams、USVString 这些值。 init 是一个对象，可包含以下字段： status：响应状态码； statusText：状态文本； headers：头部信息，普通对象或Headers 的实例。 response 的实例还有一些可读属性： ok：请求是否成功，状态码为 2xx 都为 true ； status：状态码； statusText：状态文本； bodyUesed：响应数据是否被用过； headers：头部信息； url：响应地址； type：响应类型： basic：同源； cors：跨域； error：出错； opaque：Request mode 设置为 no-cors 的响应。 response 有一些方法来 reslove 响应信息。 json，解析响应信息为对象，resolve promise； text，…………字符串…………； bolb，转化响应Bold，resolve; formData,………………； arrayBuffer，…………。 Fetch Vs AJAX 响应状态为404或5xx，都resolve，但是 ok 为false。只有当网络故障或者请求被阻止了，才会 reject； 默认情况不发送不接收cookies，需要设置； POST 的数据需要转为JSON; 不能设置超时和取消请求，可以通过Promise.race，了模拟两者； 文件上传和下载获取不到进度，可使用 response.body 是可读流，具有getReader，可根据这个来获取下载进度。； 不能直接获取到响应数据，需要调用响应方法，resolve 一下； 总结 Fetch API 很底层，使用起来并不丝滑； Fetch 错误处理有点复杂； Fetch 不支持取消和超时设置； 上传和下载进度没有，使用可读流来获取，复杂性突然升高了。 还是使用原生的 xhr 和 axios 库来的爽快。 参考 Fetch: Download progress Fetch: Abort 了解 Fetch API Fetch进阶指南]]></content>
      <categories>
        <category>网络</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>fetch</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 组件封装]]></title>
    <url>%2F2019%2F06%2F05%2Fvue-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文记录一下 Vue 组件封装的基本实践和一些组件的相关知识。主要涉及以下知识点： 封装一个组件的代码组织形式； vue 组件的三大核心： 属性（props、data）; 事件 插槽 样式 其他一些杂项 $nextTick 函数的使用 获取 DOM 元素及在父级组件中执行子组件方法 使用第三方计数库 countup.js 创建一个 count-to 组件对以上知识进行总结。 文件组织形式 在组件文件夹 component 下创建一个与组件名相同的文件，文件夹内必须有 index.js,并将组件导入到该文件中，这样方便我们引用组件。 count-to 文件夹内： 123// index.jsimport CountTo from './count-to.vue'export default CountTo 使用组件时，只需这样引入： 1import CountTo from '_c/count-to' // _c 是组件存放路径 Vue 组件的三大核心 属性（props、data 和样式） props 定义了组件可配置的数据，确定的组件的核心功能。封装组件时，props 推荐写成对象形式，方便对数据进行验证，提高了代码健壮性也能明确如何使用。 常见的检查类型：Number、String、Boolean、Array、Object、Date、Function、Symbol、构造函数。null|undefined 会通过所有类型。 还可以自定义验证函数，指定是否必须和默认值。 1234567891011121314151617181920212223242526272829props:&#123; // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125;&#125; 通过阅读 countUP 文档，了解到构造函数CountUp 的参数 1CountUp(eleDOM, startValue, endValue, decimals, duration, options) // eleDOM 是数值显示的元素；endValue 是数值的最终值，这两个参数必须的。 组件代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;template&gt; &lt;div&gt; &lt;span :id="eleId"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountUp from 'countup' export default &#123; name: 'CountTo', props: &#123; /** * @description 起始值 */ startValue: &#123; type: Number, default: 0, &#125;, /** * @description 终止值 */ endValue: &#123; type: Number, required: true, &#125;, /** * @description 小数点后保留几位小数（精度） */ decimals: &#123; type: Number, default: 0, &#125;, /** * @description 渐变时长(秒) */ duration: &#123; type: Number, default: 1, &#125;, /** *@description 变速效果 */ useEasing: &#123; type: Boolean, default: false, &#125;, /** *@description 分组 */ useGrouping: &#123; type: Boolean, default: true, &#125;, /** *@description 分组符号 2,2234 */ separator: &#123; type: String, default: ',', &#125;, /** *@description 整数小数分隔符 34.56 */ decimal: &#123; type: String, default: '.', &#125;, /** * @description 动画延迟（秒） */ delay: &#123; type: Number, default: 0, &#125;, &#125;, data() &#123; return &#123;&#125; &#125;, computed: &#123; eleId() &#123; // 使用 this.uid 生成组件内唯一id return `count_up_uid$&#123;this._uid&#125;` &#125;, &#125;, mounted() &#123; // TODO: this.$nextTick this.$nextTick(() =&gt; &#123; let options = &#123; useEasing: this.useEasing, useGrouping: this.useGrouping, separator: this.separator, decimal: this.decimal, &#125; this.counter = new CountUp( this.eleId, this.startValue, this.endValue, this.decimals, this.duration, options ) &#125;) &#125;, &#125;&lt;/script&gt; 代码说明： this._uid 用于生成组件内唯一的 id 值，可用作元素的 id，值是递增的。 this.$nextTick 函数接收一个回调函数作为参数，回调函数会在 DOM更新 之后执行，如果某些操作必须在 DOM 更新之后，可将这些操作作为其参数。 计数组件的基本功能就满足了。 这样使用组件： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" title="这个会挂载到组件根元素上" &gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo, &#125;, data() &#123; return &#123; endValue: 4000, decimals: 2, className: '', &#125; &#125;, &#125;&lt;/script&gt; 1&lt;count-to :end-value="endValue" :decimals="decimals" :duration="5"&gt;&lt;/count-to&gt; prop 的命名： 组件中使用小驼峰命名，传递值是使用-。 关于 props 传递静态值： 不使用 v-bind 即 : 传递的是静态值，是一个字符串字常量，而不是变量，而使用:指令传递的值，是有类型的。:duration=&quot;5&quot; 传递是 数值 5，duration=&quot;5&quot; 传递字符串'5'。 duration=&quot;true&quot; 传递的是字符串true 而不是 Boolean 值真值。 默认值： 传递是引用类型的值（对象和数组），默认值需要使用一个工厂函数返回一个引用类型的值。 inheritAttrs： 如果传递一个组件中没有声明的属性，该属性会挂载都组件元素上，可在组件中将 inheritAttrs 设置为 false 取消这一行为。上面的 title 属性会挂载到组件的 div 上。该属性不应 style 和 calss 的传递。 12345678&lt;count-to title="会挂载到组件的根元素上" test="test" :end-value="endValue" :decimals="decimals" :duration="5"&gt;&lt;/count-to&gt; title 会成为count-to 组件的根元素的属性： 123&lt;div title="这是标题" test="测试"&gt; &lt;span id="count_up_uid14"&gt;10,000.00&lt;/span&gt;&lt;/div&gt; $attrs 接收没有声明的属性 title 和 test 属性没有在组件中声明，依然可以在组件中使用 attrs 接收到些属性： &lt;span&gt;没有props接收的父组件数据：&lt;/span&gt;&lt;br/&gt; 最后的结果： 12345&lt;div title="这是标题" test="测试"&gt; &lt;span&gt;没有props接收的父组件数据：&#123; "title": "这是标题", "test": "测试" &#125;&lt;/span &gt;&lt;br /&gt; &lt;span id="count_up_uid14"&gt;10,000.00&lt;/span&gt;&lt;/div&gt; inheritAttrs: false 和 $attrs 结合使用： 有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些特性会被赋予哪个元素，而不需要声明变量接收。 See the Pen $attrs使用 by JackZhouMine (@JackZhouMine) on CodePen. data vs props props 从父级组件入，传入的值由父级组件维护，不允许在子组件中直接操作,是否必需和数据类型都是确定的，我们不能改变。 data 是组件内部维护的状态，组件可直接操作，可随时改变值、类型等。 相同点：都是组件的属性，改变两者都会响应到模板上。 打破 props 单向数据流 Vue 不允许在子组件中直接操作 props ,否则会报错，因为父组件和子组件都可直接操作 props，会使得 props 的管理变得混乱。可通过一些间接的方式操作 props: 将 props 赋值给 data ，然后操作 data; 在计算属性中返回 props; 以上两种方式，修改后的值，是不能会响应到父组件的，想要在父级组件中也看到修改，需要用到下面的方式： .sync 和 $emit 结合 传递 props 时加上 .sync 修饰符，在子组件内部使用 $emit 更新 props。 使用 .sync 需要注意： 不能和表达式一起使用：v-bind:title.sync=&quot;doc.title + '!'&quot;; 不能传递对象字面量：v-bind.sync=&quot;{ title: doc.title }&quot;。 传递引用类型的 props 传递数组和对象，在子组件中修改他们，会直接反应到父组件上。 事件 传统的 web 开发使用事件驱动： 查询节点 → 绑定事件监听； 用在页面上触发事件 → 执行监听器，修改 DOM,反馈到页面上； 这种模式开发效率低成本高。 Vue 的核心思想是数据驱动，视图由数据决定。MVVM 架构的页面变化流程： View(用户操作) → 执行 DOMlistenrs (ViewModel) → Data 改变 （Model）→ View 改变。 组件和绑定原生事件和自定义事件，绑定原生事件时，需要添加native修饰符。 可以在组件的原生事件处理器中触发一个自定义事件，就能在父级组件中监听该事件，执行相关操作。 在 count-to 声明一个 changeValue 事件： 增加一个按钮： 1&lt;button @click="add"&gt;+&lt;/button&gt; 在事件处理器add中触发一个自定义事件： 123add() &#123; this.$emit("changeValue", Math.random() * 100);&#125; $emit 的第一个参数是事件名称，第二个参数是传递到该事件监听器的参数。 在组件上监听 changValue: 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" @changeValue="changeValue" &gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo, &#125;, data() &#123; return &#123; endValue: 4000, decimals: 2, &#125; &#125;, methods: &#123; changeValue(value) &#123; this.endValue += value &#125;, &#125;, &#125;&lt;/script&gt; 自定义一个更新结束事件： 12345678910111213141516171819202122232425262728&lt;script&gt; import CountUp from 'countup' export default &#123; name: 'CountTo', methods: &#123; getCount() &#123; // 使用 id 获取 DOM let span = document.getElementById(this.eleId) let currentValue = Number.parseFloat(span.innerText.split(',').join('')) return currentValue.toFixed(this.decimals) &#125;, emitEnd() &#123; this.$emit('on-end', this.getCount()) // this.$emit('on-end', this.endValue) 使用 endValue 不是 库处理后的值，所有使用 DOM 元素获取更新后的值 &#125;, &#125;, // 监听 props 属性的变化 watch: &#123; endValue(newValue) &#123; // update 是库的方法 this.counter.update(newValue) setTimeout(() =&gt; &#123; this.emitEnd() &#125;, this.duration * 1000 + 2) &#125;, &#125;, &#125;&lt;/script&gt; 在组件上使用监听on-end: 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" @on-end="endUp" &gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo, &#125;, data() &#123; return &#123; endValue: 4000, decimals: 2, &#125; &#125;, methods: &#123; // 更新接收后，会触发自定义事件，然后执行该函数 endUp(value) &#123; console.log('endValue =&gt; ', value) &#125;, &#125;, &#125;&lt;/script&gt; 表单修饰符 lazy ： 在change事件同步数据； trim ： 删除首尾空格； number ：只能输入数字； 事件修饰符 stop：阻止冒泡； prevent :阻止默认行为； 123456&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on :click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on :submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt; 插槽 props 传递普通的数据类型，插槽提供了传递 HTML 代码的方式，父组件中给的插槽内容，会被放置到子组件的指定为位置。 父组件决定是否显示插槽和怎样显示，子组件决定插槽显示的位置。 三种插槽： 匿名插槽； 命名插槽； 作用域插槽。 我们现在想要在 数值左边显示一个从父级组件传递到组件中的文字提示，数值右边显示人民币符号。 可使用插槽接收文字提示和人民币符号： 123456789&lt;template&gt; &lt;div&gt; &lt;!-- 匿名插槽 找不到放置的位置，就放在这里--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;span :id="eleId"&gt;&lt;/span&gt; &lt;slot name="right"&gt;&lt;/slot&gt; &lt;!-- 命名插槽--&gt; &lt;/div&gt;&lt;/template&gt; 在父级组件传递插槽内容： 12345678&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5"&gt; &lt;span&gt;金额：&lt;/span&gt; &lt;span slot="right"&gt; ￥&lt;/span&gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt; 最后的 html 是这样的： 12345&lt;div&gt; &lt;span&gt;金额：&lt;/span&gt; &lt;span id="count_up_uid13"&gt;4,000.00&lt;/span&gt; &lt;span&gt; ￥&lt;/span&gt;&lt;/div&gt; 不传递插槽内容时，可以在组件中设置一个默认的插槽内容： 1234567&lt;template&gt; &lt;div&gt; &lt;slot&gt;奖金额度：&lt;/slot&gt; &lt;span :id="eleId"&gt;&lt;/span&gt; &lt;slot name="right"&gt; ￥&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 父级组件的作用域和子组件的作用是独立的，在父级组件的插槽内容中，获取不到子组件的数据。 12345678&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="parentDecimals" :duration="5"&gt; &lt;span&gt;精确到几位小数：&#123;&#123;parentDecimals&#125;&#125;&lt;/span&gt; &lt;span slot="right"&gt;&#123;&#123;decimals&#125;&#125;&lt;/span&gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt; parentDecimals 是父级组件中的属性，插槽内容属于父级作用域，可获取父级的数据； decimals 是子级组件中的属性，插槽内容属于父级作用域，获取不到值； 想要在父级插槽内容中获取子组件的数据，就需要用到作用域插槽。 现在想要把数值前面的文字从父级组件传递到子组件，并且还要传递文字的颜色： 1234text: &#123; name: "本月工资", color: "#F4D03F"&#125;, 子组件这样定义： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;!--向父级组件传递text 并起了名字--&gt; &lt;slot v-bind="text" name="left"&gt;奖金额度：&lt;/slot&gt; &lt;span :id="eleId" ref="number"&gt;&lt;/span&gt; &lt;slot name="right"&gt; 元&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountUp from 'countup' export default &#123; name: 'CountTo', props: &#123; // 增加 prop text: &#123; type: Object, default: () =&gt; &#123;&#125;, &#125;, &#125;, &#125;&lt;/script&gt; 这样使用组件： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" :text="text" &gt; &lt;template slot-scope="data" slot="left"&gt; &lt;span :style="&#123;color:data.color&#125;"&gt;&#123;&#123;data.name&#125;&#125;：&lt;/span&gt; &lt;/template&gt; &lt;span slot="right"&gt;￥&lt;/span&gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo, &#125;, data() &#123; return &#123; text: &#123; name: '本月工资', color: '#F4D03F', &#125;, endValue: 4000, decimals: 2, &#125; &#125;, &#125;&lt;/script&gt; &lt;slot v-bind=&quot;text&quot;&gt;奖金额度：&lt;/slot&gt;，向父级组件传递数据； slot-scope=&quot;data&quot; 用来接收插槽传递到父组件的数据； 新指令 v-slot 在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 。 子组件： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;!-- 向父级组件传递 textFromChild --&gt; &lt;slot :textFromChild="text" name="left"&gt;奖金额度：&lt;/slot&gt; &lt;span :id="eleId" ref="number"&gt;&lt;/span&gt; &lt;slot name="right"&gt; 元&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountUp from 'countup' export default &#123; name: 'CountTo', props: &#123; // 增加 prop text: &#123; type: Object, default: () =&gt; &#123;&#125;, &#125;, &#125;, &#125;&lt;/script&gt; 这样使用组件： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" :text="text" &gt; &lt;template v-slot:left="&#123;textFromChild&#125;"&gt; &lt;span :style="&#123;color:textFromChild.color&#125;" &gt;&#123;&#123;textFromChild.name&#125;&#125;：&lt;/span &gt; &lt;/template&gt; &lt;span slot="right"&gt;￥&lt;/span&gt; &lt;/count-to&gt; &lt;/div&gt;&lt;/template&gt; 子组件传递过来的变量被放置在一个对象中，使用解构赋值的方式提取出来。 123&lt;template v-slot:left="&#123;textFromChild&#125;"&gt; &lt;span :style="&#123;color:textFromChild.color&#125;"&gt;&#123;&#123;textFromChild.name&#125;&#125;：&lt;/span&gt;&lt;/template&gt; v-slot 指令后跟一个 slot 的名字，插槽具有名字时，可简写为#。 123&lt;template #left="&#123;textFromChild&#125;"&gt; &lt;span :style="&#123;color:textFromChild.color&#125;"&gt;&#123;&#123;textFromChild.name&#125;&#125;：&lt;/span&gt;&lt;/template&gt; 不管有几个插槽，都把插槽内容放置在 template 中是很好的做法。 其他杂项 组件生成 id 使用this_uid其他字母，可成组件内唯一的 id。 count-to组件中，我们使用计算属性，设置 span 的 id。 1234eleId() &#123; // 使用 this.uid 生成全局唯一id return `count_up_uid$&#123;this._uid&#125;`; &#125;, 在组件内部，可以通过 id 或者 class 等获取到 dom，但是不推荐这么做。可通过ref 属性，获取到DOM，更加简洁，并且可以直接通过ref 获取组件或者DOM元素。 在下面的函数中获取 DOM： 1234567891011getCount() &#123; // TODO: 获取 DOM // 使用 ref 属性获取 DOM 元素 // console.log(this.$refs.number.innerText) // return this.$refs.number.innerText // 使用 id 获取 DOM let span = document.getElementById(this.eleId); let currentValue = Number.parseFloat(span.innerText.split(",").join("")); return currentValue.toFixed(this.decimals);&#125;, $nextTick 函数的使用 this.$nextTick 接收一个回调函数作为参数，参数会在 Vue 完成 DOM 更新后立即调用。如果某些操作是依赖 DOM 更新后的，可以把这些操作放在回调函数里执行。 在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 Vue.$nexttick 全局的，this.$nexttick 是局部的。 1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; message: '123', &#125;,&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // false 此时DOM还没渲染Vue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) Vue DOM 的更新是异步的，数据变化后，组件不会立即渲染，而是在事件队列刷新时，在下一个事件循环 tick 中渲染。 $nexttick 返回一个 Promise，可使用 await 关键词调用。 12345678methods: &#123; updateMessage: async function () &#123; this.message = '已更新' console.log(this.$el.textContent) // =&gt; '未更新' await this.$nextTick() console.log(this.$el.textContent) // =&gt; '已更新' &#125;&#125; 在父级组件中调用子组件的方法 有时候需要再父级组件中调用子组件的方法。可以在使用组件时指定 ref ，然后使用 ref 调用。 比如调用组件的暂停方法，使得数据变化暂停。 在组件中定义暂停方法： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;slot :textFromChild="text" name="left"&gt;奖金额度：&lt;/slot&gt; &lt;span :id="eleId" ref="number" :class="countClass"&gt;&lt;/span&gt; &lt;slot name="right"&gt; 元&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountUp from 'countup' export default &#123; name: 'CountTo', data() &#123; return &#123;&#125; &#125;, methods: &#123; // TODO: 在父级组件中使用封装组件内部的方法 // 在父级组件中调用该方法，实现暂停 pause() &#123; this.counter.pauseResume() &#125;, &#125;, &#125;&lt;/script&gt; 在父组件中使用调用组件暂停方法。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;count-to :end-value="endValue" :decimals="decimals" :duration="5" ref="countTo" &gt; &lt;!-- 指定 ref --&gt; &lt;template #left="&#123;textFromChild&#125;"&gt; &lt;span :style="&#123;color:textFromChild.color&#125;" &gt;&#123;&#123;textFromChild.name&#125;&#125;：&lt;/span &gt; &lt;/template&gt; &lt;span slot="right"&gt;￥&lt;/span&gt; &lt;/count-to&gt; &lt;button @click="pasue"&gt;暂停&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CountTo from '_c/count-to' export default &#123; name: 'count_to', components: &#123; CountTo, &#125;, data() &#123; return &#123; endValue: 4000, decimals: 2, &#125; &#125;, methods: &#123; pasue() &#123; // 使用 refs 访问组件，然后调用器方法 this.$refs.countTo.pause() &#125;, &#125;, &#125;&lt;/script&gt; 样式 组件使用样式，用三种方式： 外部样式； 内部样式； 通过 props 传入 类名，以指定使用内部样式中的哪个类名。 外部样式两种方法引入： 在 script 标签中引入和在 style 标签中引入。 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;slot :textFromChild="text" name="left"&gt;奖金额度：&lt;/slot&gt; &lt;!-- 将 props 中的类绑定到 class 上 --&gt; &lt;span :id="eleId" ref="number" :class="countClass"&gt;&lt;/span&gt; &lt;slot name="right"&gt; 元&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入样式方法一： // import './count-to.css' import CountUp from 'countup' export default &#123; name: 'CountTo', inheritAttrs: true, // 不让父作用域的属性挂载到组件的根元素上 props: &#123; /** * @description 自定义样式类名 */ className: &#123; type: String, default: '', &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="css"&gt; /* 引入样式方法二 */ /* @import './count-to.css' */ /* 内部样式 */ .count-to-number &#123; color: red; font-size: 30px; &#125;&lt;/style&gt; 通过 props 传递类名，实际是在父级组件中指定使用内部样式中的哪个类。 通过 style 也可以应用样式到组件上。 总结 封装一个组件 props 和 data 决定了组件的核心功能，插槽用于向组件传递 html 标签，使得组件更加具有扩展性。通过事件我们可以对组件进行某些操作。改天分析一个第三方组件，好好体会一下这些概念。 参考 详解 vue 组件三大核心概念 简单理解 Vue 中的 nextTick vue.nextTick 的原理和用途 nextTick What the Tick is Vue.nextTick? vue 文档 Prop]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 状态管理（三）]]></title>
    <url>%2F2019%2F05%2F26%2Fvue-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们修改 state，然后刷新浏览器，状态又变化原来的了，因为 state 是存在内存中的，为了点击刷新，状态不回到原来的，就需要 Vuex 提供的插件功能，当然插件还能实现其他复杂的功能。 插件 Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 store 作为唯一参数： 1234567const myPlugin = store =&gt; &#123; // 当 store 初始化后调用 store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation 的格式为 &#123; type, payload &#125; &#125;)&#125; 使用插件： 1234const store = new Vuex.Store(&#123; // ... plugins: [myPlugin]&#125;) 使用插件本地 state 持久化。 1234567891011121314151617181920//localstore.jsexport default store =&gt; &#123; // 当 store 初始化后调用 console.log('store 初始化', JSON.stringify(store.state, '', 2)) // 已经初始化 // 不能 store.state = '' 直接赋值方式改变 state if (localStorage.getItem('state')) store.replaceState(JSON.parse(localStorage.state)) store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 localStorage.state = '' try &#123; localStorage.setItem('state', JSON.stringify(state)) &#125; catch (error) &#123; console.log('持久化遇到错误') console.error(error) &#125; console.log('mutation', mutation) // mutation 的格式为 &#123; type, payload &#125; &#125;)&#125; 修改 store 12345678910111213// 引入插件import &#123; localStore &#125; from './plugins'Vue.use(Vuex)export default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; user &#125;, plugins: [localStore]&#125;) 启用插件后，调用 commit 更新 state 后，会更新本地存储，即使实现浏览器，值也不会变。 处理表单 在学习 mutations 时，我们使用表单的值更新state，我们这样写 1234&lt;input type="text" name="age" id="age" v-model="age" placeholder="请输入年纪" /&gt;&lt;button @click="changeAge"&gt;修改年纪&lt;/button&gt;&lt;p&gt;年纪:&#123;&#123;this.$store.state.age&#125;&#125;&lt;/p&gt;&lt;input type="text" v-model="lastName" placeholder="请输入姓氏" @input="changeLastName" /&gt; 1234567891011121314151617181920212223import &#123; mapMutations &#125; from 'vuex'export default &#123; name: 'Store', data() &#123; return &#123; age: '', lastName: "" &#125; &#125;, methods: &#123; //方法名和 muations 相同 ...mapMutations(['CHANGE_LAST_NAME', 'CHANGE_AGE']), // 将 `this.changeAge2()` 映射为 `this.$store.commit('CHANGE_AGE')` ...mapMutations(&#123; changeAgeAlias: 'CHANGE_AGE' &#125;), changeAge2() &#123; this.changeAgeAlias(&#123; age: Number.parseInt(this.age) &#125;) &#125;, changeLastName() &#123; // this.$store.commit('CHANGE_LAST_NAME', this.lastName) this.CHANGE_LAST_NAME(this.lastName) &#125;, &#125;&#125; 以上方式都是在方法中提获取表单的输入值，需要再data里生属性。其实我们可以在计算属性中使用setter、getter中实现，充分利用 v-model 双向绑定的特性来简化了代码。 1234567891011121314151617181920&lt;template&gt; &lt;div class="store"&gt; &lt;p v-text="this.$store.getters.fullName"&gt;&lt;/p&gt; &lt;input type="text" v-model="lastName" placeholder="请输入姓氏" @input="changeLastName" /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'Store', computed: &#123; lastName: &#123; get() &#123; return this.$store.state.lastName &#125;, set(newLastName) &#123; this.$store.commit('CHANGE_LAST_NAME', newLastName) &#125; &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 状态管理（二）]]></title>
    <url>%2F2019%2F05%2F26%2Fvue-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上篇文章中说了 state 和 getters，本篇文章就来说说 mutations 和 actions。 提交 mutations 是改变 state 的唯一方式，不能用异步操作。actions 通过分发 action 来提交 mutation，可包含异步操作，比如 xhr 。 mutations 声明 mutations: 123456789101112131415// mutations.jsimport vue from 'vue'export default &#123; CHANGE_LAST_NAME(state, newLastName) &#123; state.lastName = newLastName &#125;, CHANGE_AGE(state, params) &#123; state.age = params.age + 5 &#125;, // 新增一个属性 SET_REPOS(state,repos)&#123; // 给 state 新添加属性 vue.set(state,'repoList',repos) &#125;&#125; 使用 mutations 通过 mapMutations 映射方法； 在方法中 调用 this.$store.commit('mutaion')； 可以在 mutation 种给 state 新增状态（属性），新增的状态会响应到视图上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div class="store"&gt; &lt;p&gt;基本信息：&#123;&#123;this.info&#125;&#125;&lt;/p&gt; &lt;input type="text" name="age" id="age" v-model="age" placeholder="请输入年纪" /&gt; &lt;button @click="changeAge"&gt;修改年纪&lt;/button&gt; &lt;button @click="changeAge2"&gt;修改年纪2&lt;/button&gt; &lt;p&gt;年纪:&#123;&#123;this.$store.state.age&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="lastName" placeholder="请输入姓氏" @input="changeLastName" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CustomInput from '_c/CustomInput.vue' import &#123; mapState, mapGetters, mapMutations &#125; from 'vuex' export default &#123; name: 'Store', data() &#123; return &#123; age: '', lastName: "" &#125; &#125;, methods: &#123; handleInput(val) &#123; this.value = val &#125;, //方法名和 muations 相同 ...mapMutations(['CHANGE_LAST_NAME', 'CHANGE_AGE']), // 将 `this.changeAge2()` 映射为 `this.$store.commit('CHANGE_AGE')` ...mapMutations(&#123; changeAgeAlias: 'CHANGE_AGE' &#125;), changeAge() &#123; // 传递载荷 // this.$store.commit('CHANGE_AGE', &#123; age: Number.parseInt(this.age) &#125;) //对象提交方式 // this.$store.commit(&#123; type: 'CHANGE_AGE', age: Number.parseInt(this.age) &#125;) this.CHANGE_AGE(&#123; age: Number.parseInt(this.age) &#125;) &#125;, changeAge2() &#123; this.changeAgeAlias(&#123; age: Number.parseInt(this.age) &#125;) &#125;, changeLastName() &#123; // this.$store.commit('CHANGE_LAST_NAME', this.lastName) this.CHANGE_LAST_NAME(this.lastName) &#125;, &#125; &#125;&lt;/script&gt; actions mutation 只能是同步操作，为了使用异步操作，Vuex 提供了 actions。 Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 声明 actions action 接收一个和 store 具有相同属性和方法的对象，可 context.commit 提交 mutation； 可以解构赋值，获取 commit 和 dispatch，commit 用于提交 mutation, dispatch 用于分发其他 action。 12345678910111213141516171819import http from 'axios'export default &#123; // action 接收一个和 store 具有相同属性和方法的对象，可 context.commit 提交 mutation changeAgeAsync(context, params) &#123; console.dir(context) //模拟异步操作 setTimeout(() =&gt; &#123; context.commit('CHANGE_AGE', params) &#125;, 5000) &#125;, //通过 github API 获取我的 github 仓库信息 async repos(&#123; commit, dispatch &#125;, username) &#123; let response = await http.get(`https://api.github.com/users/$&#123;username&#125;/repos`) let repoList = response.data commit('SET_REPOS', repoList) // 分发其他 action 形成组合 action dispatch('changeAgeAsync', &#123; age: 30 &#125;) // 给 state 新添加属性 不能直接改变 state // vue.set(state,'repoList',repoList) &#125;&#125; 在组件中使用 actions 通过 mapActions 映射为方法。 this.$store.dispatch。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class="store"&gt; &lt;input type="text" name="age" id="age" v-model="age" placeholder="请输入年纪" /&gt; &lt;button @click="changeAge"&gt;修改年纪&lt;/button&gt; &lt;p&gt;年纪:&#123;&#123;this.$store.state.age&#125;&#125;&lt;/p&gt; &lt;input type="text" v-model="lastName" placeholder="请输入姓氏" @input="changeLastName" /&gt; &lt;hr&gt; &lt;button @click="getRepos"&gt;获取仓库列表&lt;/button&gt; &lt;h2&gt;我的仓库列表：&lt;/h2&gt; &lt;ol&gt; &lt;li v-for="(item, index) in repoList" :key="index"&gt;&#123;&#123;item.full_name&#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; mapState, mapActions&#125; from 'vuex' export default &#123; name: 'Store', data() &#123; return &#123; age: '', lastName: "" &#125; &#125;, methods: &#123; ...mapActions(['changeAgeAsync','repos']), changeAge() &#123; // this.$store.dispatch('changeAgeAsync',&#123; age: Number.parseInt(this.age) &#125;) this.changeAgeAsync(&#123;age: Number.parseInt(this.age)&#125;) &#125;, getRepos()&#123; // this.$store.dispatch('repos','jackzhoumine') this.repos('jackzhoumine') &#125; &#125;, computed: &#123; //计算属性名和 state 属性名相同:传入数组 ...mapState(['repoList']) &#125; &#125;&lt;/script&gt; module 状态对象很复杂时用 module 划分。 这个似乎用得很少。需要用时看veux 文档即可。 总结 提交 mutation 是改变你 state 的唯一方式； 方法执行上： dispatch 分发 action ; commit 提交mutation。 辅助方法的映射 getters、state 映射为计算属性； actions、mutations 映射为法法。 分离功能： state 保存数据； getters 是对 state 的操作； actions 要提交 mutation; mutations 改变 state。 异步与同步： action 封装异步处理； mutation 只能是同步。 视图响应 ( vue component dispatch → ) vue component commit → state → （ getters →） vue component state 对象太过复杂，使用 module 划分。 参考 理解Vuex，看这篇就够了 veux 文档]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 状态管理（一）]]></title>
    <url>%2F2019%2F05%2F26%2Fvue-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[父子组件之间往往使用props和 $emit 实现数据共享，任意组件可通过bus（一个vue实例）作为桥梁，实现数据共享。当项目中组件越来越多时，组件之间的数据共享变得复杂，难以维护。使用 Vuex 可集中管理组件之间的数据（状态），使组件之间的数据共享变得简单。 父子组件间通信 父→（props）子组件；子→（$meit）父组件，即子组件自定义一个事件，在父组件中监听该事件。 自定义输入组件： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;input @input="handleInput" :value="value" :placeholder="placeholder" /&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "CustomInput", //props 接收父组件传递过来的数据 props: &#123; value: &#123; type: [Number, String], required: true, default: "" &#125;, placeholder: &#123; type: String, default: "提示文本" &#125; &#125;, methods: &#123; handleInput(event) &#123; let val = event.target.value; // 子组件的事件监听函数中触发一个自定义事件 this.$emit("customInput", val); &#125; &#125; &#125;;&lt;/script&gt; 使用组件： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class="store"&gt; &lt;!-- props 传递值 --&gt; &lt;custom-input :value="value" @customInput="handleInput" :placeholder="placeholder" /&gt; &lt;p v-text="value"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CustomInput from '_c/CustomInput.vue' export default &#123; name: 'Store', components: &#123; CustomInput &#125;, data() &#123; return &#123; value: '', placeholder: '自定义事件传递值' &#125; &#125;, methods: &#123; // 自定义事假处理器 handleInput(val) &#123; this.value = val &#125; &#125; &#125;&lt;/script&gt; 因为 v-model 指令是双向绑定的，我们也可以用其来实现值的传递： 123456789101112131415161718192021&lt;template&gt; &lt;div class="store"&gt; &lt;custom-input v-model="inputValue" :placeholder="placeholder" /&gt; &lt;p v-text="inputValue"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import CustomInput from '_c/CustomInput.vue' export default &#123; name: 'Store', components: &#123; CustomInput &#125;, data() &#123; return &#123; inputValue: '', placeholder: 'v-mode 传递值' &#125; &#125; &#125;&lt;/script&gt; bus 任意组件通信 创建一个空的 vue 实例，然后将该实例添加到 vue 的原型上，通过该实例触发事件和监听事件来在不同组件之间共享数据。 1234//bus.jsimport Vue from "vue";let Bus = new Vue();export default Bus; 在 main.js 中添加原型属性： 123import Bus from './lib/bus'// 通过 bus 实现任意组件传递参数Vue.prototype.$bus=bus 123456789101112131415161718192021222324//ChildPage.vue&lt;template&gt; &lt;div id="child-page"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;h3 v-text="data"&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "ChildPage", data() &#123; return &#123; msg: "I am child", data: "" &#125;; &#125;, mounted() &#123; // 在挂载声明周期函数中监听自定义事件 this.$bus.$on("customEvent", data =&gt; &#123; this.data = data; &#125;); &#125; &#125;;&lt;/script&gt; 123456789101112131415161718192021&lt;template&gt; &lt;div id="app"&gt; &lt;button @click="sendData"&gt;给child传递数据&lt;/button&gt; &lt;p v-text="num"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "App", data() &#123; return &#123; num: 0 &#125; &#125;, methods: &#123; sendData(data) &#123; // 由 bus 触发一个事件，在接收数据的组件中监听该事件 this.$bus.$emit('customEvent', ++this.num); &#125; &#125; &#125;;&lt;/script&gt; Vuex 状态管理 随着组件的增加，通过以上方式共享数据，会越来越复杂，vue 提供了状态管理插件 Vuex。 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式；集中存储和管理应用的所有组件状态。 理解： 状态：数据，相当于组件内部的data 的返回值，Vue 是数据驱动的，数据变化往往会表现在视图层； 集中存储：Vue 只关注视图层，Vuex 提供了一个仓库（store）来保存数据，使得数据和视图分离； 管理：处理保存数据，还可计算、处理数据； 所有组件状态：所有组件都可获取仓库中的数据，即一个项目只有一个数据源。 Vuex 文档中说： 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。 Vuex 就是通过隔离数据、拆分改变数据的方式使得数据和视图独立，数据被组件数共享。 虚线内部的三个部分组成了一个Store,组件的数据保存在 State 中，用户和组件交互时，通过组件内的方法分发（dispatch）一个动作（action，有点像事件），动作会提交（Commit）一个更改（Mutation，也类似事件），改变 State 中的数据，然后获取数据渲染到视图上。 actions 可以是 异步操作，故可在action中调用后台接口获取新的数据； mutations 只能是 同步操作； mutations 和 actions 都可直接更改 state，但是当 action 含有异步操作时，会使得数据变化混乱，难以跟踪，使得调试困难； 基于以上原因，Vuex 规定只能是 mutations 来改变 state。 在开发工具中也可提交 mutations。 使用 vuex 12345678910111213141516171819202122232425262728293031323334353637383940414243//main.jsimport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);// Vuex 是 Vue 的插件let store = new Vuex.Store(&#123; state: &#123; //放置state的值 count: 0, str:"abcd234" &#125;, getters: &#123; //放置getters方法 strLen: state =&gt; state.str.length &#125;, // mutations只能是同步操作 mutations: &#123; //放置mutations方法 increment(state, payload) &#123; //在这里改变state中的数据 state.count = payload.number; &#125; &#125;, // actions可以是异步操作 actions: &#123; //放置actions方法 actionName(&#123; commit &#125;) &#123; //dosomething commit('mutationName') &#125;, getSong (&#123;commit&#125;, id) &#123; //请求后台数据 api.getMusicUrlResource(id).then(res =&gt; &#123; let url = res.data.data[0].url; &#125;) .catch((error) =&gt; &#123; // 错误处理 console.log(error); &#125;); &#125; &#125;&#125;);new Vue(&#123; el: '#app', store // 通过 this.store 访问 store&#125;); 我们看看 Vuex 和 store 是什么？ Vuex： Vuex 它实际上是一个对象，里面包含了Store这一构造函数，还有几个mapActions、mapGetters、mapMutations、mapState、install 方法。 store： store 是 Vuex 的实例（废话）。 实际项目中往往将 store 单独放置的一个文件夹在，mutations 、getters、actions 等属性各自用一个文件保存。 state state 对象的属性时 Vuex 管理的状态，类似单个组建的 data。 访问 getters: this.$store.state； 使用 mapState 映射成计算属性，推荐。 12345678910//state.jsexport default &#123; count: 100, name: 'Jack*Zhou', firstName: 'Jack', lastName: 'Zhou', age: 24, profession: 'web deveploper', company: 'Baidu'&#125; 组件： 12345678910111213141516171819202122232425import &#123;mapState&#125; from 'vuex'export default &#123; data()&#123; return &#123; localCount:0 &#125; &#125;, computed: &#123; localCount() &#123; return this.$store.state.count + 1; &#125;, //计算属性名和 state 属性名相同:传入数组 // ...mapState(['count','name']), // 计算属性名和 state 属性不同，传入对象 ...mapState(&#123; name: state =&gt; state.name, count: state =&gt; state.count, countAlias: 'count', //为了使用 this 不能使用箭头函数 countPlusLocalCount(state) &#123; return state.count + this.localCount; &#125; &#125;) &#125;,&#125; getters getters 是对 state 的加工，类似于组件中的 data 和计算属性的关系。getters 的返回值会被缓存起来，只有当它的依赖改变，才会重新计算。 访问 getters: this.$store.getters； 使用 mapGetters 将 getters 映射成计算属性，推荐； 方法访问，不会缓存。 1234567891011121314151617// getters.jsexport default &#123; fullName: state =&gt; state.firstName + ' ' + state.lastName, //在getters 中访问 getters info: (state, getters) =&gt; &#123; return state.age + ',' + getters.fullName; &#125;, //为了传递参数，返回一个函数， personInfo: (state, getters) =&gt; (city) =&gt; &#123; return &#123; name: getters.fullName, age: state.age, company: state.company, city &#125; &#125;&#125; 使用 getters: 12345678910111213141516171819import &#123; mapGetters &#125; from 'vuex'export default &#123; name: 'Store', computed: &#123; ...mapGetters(['fullName', 'info', 'personInfo']), myInfo() &#123; return this.personInfo('杭州') &#125;, ...mapGetters(&#123; fullNameAlias1: 'fullName', //不能写成函数 // fullNameAlias2(state)&#123; // return state.name+'，你好'+this.$store.getters.fullName; // &#125; &#125;) &#125;, mounted() &#123; console.log(this.personInfo('成都')) console.log(this.myInfo) &#125;&#125; 参考 理解Vuex，看这篇就够了 vuex 文档]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 路由进阶]]></title>
    <url>%2F2019%2F05%2F25%2Fvue%20%E8%B7%AF%E7%94%B1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[路由可向路由匹配的组件传递参数，不同情况向组件传递不同的参数，从而实现组件的复用。 [TOC] 路由向组件传递参数 和路由匹配的组件可以在组件中使用 $route 获取路由上的参数： 传参方式 :、params和query :在路径传递参数 12345&#123; path: "/argu/:id/book", name: "argu", component: () =&gt; import("@/views/ArguPage")&#125; 路径中的一部分是参数，必须传递该参数： 123456&lt;!--路径跳转--&gt;&lt;router-link to="/argu/123/book"&gt;path跳转&lt;/router-link&gt;&lt;!--路由名跳转--&gt;&lt;router-link :to="&#123;name:'argu',params:&#123;id:'test'&#125;&#125;" tag="button"&gt;name+params跳转&lt;/router-link&gt;&lt;!--获取参数--&gt;&lt;h1&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/h1&gt;&lt;!--params的名字路径中的的参数名一致--&gt; 此时 path+ parmas传递参数，params会被忽略。 params+name传递参数 路由： 12345&#123; path: "/argu", name: "argu", component: () =&gt; import("@/views/ArguPage")&#125; 跳转方式是 name+params+（query），通过path跳转，params 会被忽略。 1234567&lt;router-link :to="&#123;name:'argu', params:&#123;name:'hangge'&#125;&#125;"&gt; 跳转到 hello&lt;/router-link&gt;// path + params ，params 会被忽略，因为路径中没有定义参数&lt;router-link :to="&#123;path:'/argu', params:&#123;name:'hangge'&#125;&#125;"&gt; 跳转到 hello&lt;/router-link&gt; query 参数 query 参数参数，表现为查询字符串，和localtion.serach一样的。 不需要先在路径中先定义，可通过path、path+query 或者 name + query 传递参数。 1234&lt;router-link to="/argu?queryName=value"&gt;跳转到 hello&lt;/router-link&gt;&lt;router-link :to="&#123;path:'/argu',query:&#123;queryName:value&#125;&#125;"&gt;跳转到 argu&lt;/router-link&gt;&lt;router-link :to="&#123;name:'argu',query:&#123;queryName:value&#125;&#125;"&gt;跳转到 argu&lt;/router-link&gt;&lt;h1&gt;&#123;&#123; $route.query.queryName &#125;&#125;&lt;/h1&gt; 函数传递 query 12345678910// 主要是 $router 不是 $routego() &#123; this.$router.push(&#123; name: 'argu', query: &#123; queryName: "你好" &#125; &#125;) &#125;&#125; 但是这样使得 $route 和组件耦合在一起，不方便组件的复用，如果能将路由中的参数传递到 组件的props 就好了，恰恰是可以这样设置的。 props 接收路由的 params 路由传参数的三种方式： 布尔模式 12345&#123; path: '/user/:id', component: User, props: true //表明 将 id 作为 proos 传递到匹配的组件 User 中。&#125; User 中定义 props 接收 id: 12345678export default &#123; props:&#123; id:&#123; type:String, default:'jackzhou'//默认值 &#125; &#125;&#125; 对象模式 将路由的 props 属性设置一个对象，也可在组件中获取到该值，这种方式往往用于传递静态值，即 name 值不会变化。 路由对象： 1234567&#123; name: 'home', alias:'/home_page', path: '/', props:&#123;name:'jack jack'&#125;, component: Home&#125; Home 组件： 12345props:&#123; name:&#123; type:String, &#125;&#125; 函数模式 以上两种方式，params 参数的名字必须和组件中的props 属性名字相同，如果想对 params 进行改造后传递到组件，就可将 props 设置成函数，在函数内获取路由中的 params 或者 query，或者其他属性值，对其进行处理后再传递给组件。 注意：这种方式函数必须返回一个对象。 路由： 123456789101112&#123; name: 'about', path: '/about/:years', //params 有一个参数 years props:(route) &#123; const now = new Date() return &#123; // 将 years 改造成 name name: (now.getFullYear() + parseInt(route.params.years)) + '!' &#125; &#125;, component: () =&gt; import('@/views/AboutPage'),&#125; 组件中的 props: 12345props: &#123; name: &#123; type: String &#125;&#125; 命名视图的路由，要为每个命名视图添加 props： 1234567891011121314&#123; path:'/name/:view', name:'name_view', components:&#123; default:()=&gt;import('@/views/ChildPage'), sister:()=&gt;import('@/views/SisterPage'), brother:()=&gt;import('@/views/BrotherPage'), &#125;, props:&#123; default:true, sister:false, brother:(route)=&gt;(&#123;view:route.params.view.toUpperCase()&#125;) &#125;&#125; 完整的例子 See the Pen route 的 params 传递组件 by JackZhouMine (@JackZhouMine) on CodePen. HTML5 History 模式 路由配置里有一个属性 mode ，默认值是 hash，以hash来模拟一个url，url改变时，页面不会重新加载。 先使用普通模式，可将 mode 设置成 history，这种模式会使用 history.pushSate 来完成url跳转而页面不会重新加载。这种模式需要服务器设置一下。 使用 history 模式，因为web应用往往是单页应用，当用户访问一个不存在的路径时，需要提供一个后备页面。 在路由配置的最后增加一个404路由： 1234&#123; path:'*', component:NotFoundPage// 前面没有匹配的路由，最后会匹配该路由。&#125; meta 元信息 可在路由对象中配置 meta 属性，meta 是一个对象。 比如，根据不同页面显示不同的 title。 12345678&#123; name: "about", path: "/about", meta: &#123; title: "关于" &#125;, component: () =&gt; import("@/views/AboutPage") &#125; 在路由配置文件中，设置各个页面的 title： 1234567891011const router= new Router(&#123; routes&#125;)router.beforeEach((to,from,next)=&gt;&#123; //setTitle 函数用于设置页面标题 to.meta&amp;&amp;setTitle(to.meta.title) //这是简化if语句的简写 console.table(to) console.table(from) next()&#125;)export default router 导航守卫 全局守卫 全局前置守卫 1234567891011121314151617const router = new Router(&#123; &#123; path:"/", name:"heom_page" component:Home, //路由独享守卫 beforeEnter:(to,from,next)=&gt;&#123; //处理逻辑 next() &#125; &#125;&#125;)//每次路由进入都会调用router.beforeEach((to,from,next)=&gt;&#123; //处理逻辑，比如登录判断，可跳转到任意页面 //不要忘记调用 next，不调用 next，页面不会跳转&#125;) 后置钩子 1234//路由跳转之后做一些操作，比如去掉登录样式router.afterEach((to,form)=&gt;&#123; //逻辑处理&#125;) 路由独享守卫 只在匹配某个路由时执行。 组件内守卫 beforeRouteEnter, 组件创建之前调用，组件不具备this； beforeRouteUpdate，路由更新，而组件被复用时调用，可使用this； beforeRouteLeave，离开路由时调用，可使用this。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778export default&#123; name:'Home', data()&#123; return &#123;&#125; &#125;, /** * 组件内路由守卫 * 1. 该函数在路由进入时执行 * 2. 此时 组件还未渲染，不可用 this,当可在 next 中用 vm * 3. next 晚于 mounted 执行，next 之前的代码，早于beforeCreate * 执行 * 4. 最后需要调用 next 使得路由跳转 */ beforeRouteEnter(to, from, next) &#123; console.log("①，home 组件内路由守卫，beforeRouteEnter"); // next 晚于 mounted 执行，next 之前的代码，早于beforeCreate 执行 next((vm)=&gt;&#123; console.log('vm') console.log(vm)//有值 console.log('this') console.log(this)// undefined console.log('②，home 组件内路由守卫，beforeRouteEnter'); &#125;); &#125;, /** * 组件内路由守卫 * 1. 该函数在路由离开时执行,最先调用,然后在调用全局守卫，再调用 * beforeDestroy * 2. 此时，该路由守卫所在组件已渲染，可用 this * 3. 最后需要调用 next 使得路由跳转 */ beforeRouteLeave(to, from, next) &#123; console.log("①，home 组件内路由守卫，beforeRouteLeave"); let leave = confirm("你确定要离开 home 页吗？"); if (leave) &#123; // console.log(to.name, from.name); // console.log(this); next(() =&gt; &#123; console.log('②，home 组件内路由守卫，beforeRouteLeave'); &#125;); //给 next 传递 false ,路由不会跳转 &#125; else &#123; next(false); &#125; &#125;, /* * 当路由发生变化，而组件被复用时调用 * 1. 此时该复用组件已被渲染，可用 this * 2. 需要调用 next，组件才能渲染 */ beforeRouteUpdate(to, from, next) &#123; console.log('①，argu，组件内路由守卫，beforeRouteUpdate'); next(() =&gt; &#123; console.log('next，argu，组件内路由守卫，beforeRouteUpdate'); &#125;); &#125;, beforeCreate() &#123; console.log('beforeCreate') &#125;, created() &#123; console.log('created') &#125;, beforeMount() &#123; console.log('beforeMount') &#125;, mounted() &#123; console.log('mounted') &#125;, beforeUpdate() &#123; console.log('beforeUpdate') &#125;, updated() &#123; console.log('updated') &#125;, beforeDestroy() &#123; console.log('beforeDestroy') &#125;, destroyed() &#123; console.log('destroyed') &#125;&#125; 路由全过程： 导航被触发 离开页面（失活的组件）里调用离开守卫 beforeRouteLeave 调用全局前置守卫 beforeEach 在重用的组件里调用 beforeRouteUpdate (非重用组件，没有这个步骤) 调用路由独享守卫 beforeEnter 解析异步路由组件 在进入页面（激活组件）调用 beforeRouteEnter 调用全局解析守卫 beforeResolve （导航被确认之前，组件内守卫和异步路由组件被解析之后，调用 beforeResolve） 导航被确认（什么时候被确认，全部钩子执行完了，是被确认的） 调用全局后置守卫 afterEach 触发 DOM 更新 在 vue 实例中（此时页面解析完毕了吗？是的）调用 beforeRouterEnter 守卫里传给 next 的回调。next在mounted之后被调用。 过渡效果 可以给路由匹配的组件设置过渡效果，让页面平滑地显示，提升用户体验。 需要用到 transition 标签，如果有多个视图需要过渡，则用 transition-group。 1234567&lt;transition-group name='router-view'&gt;&lt;!-- 视图渲染组件,该组件内不需要房子任何内容，可写成只闭合标签--&gt; &lt;router-view key='default'/&gt; &lt;!-- 有多个路由视图需要匹配，则用命名视图 --&gt; &lt;router-view key='sister' name="sister"&gt;&lt;/router-view&gt; &lt;router-view key='brother' name="brother"&gt;&lt;/router-view&gt;&lt;/transition-group&gt; css 过渡效果： 1234567891011121314151617181920.router-view-enter&#123; opacity: 0;&#125;.router-view-enter-active&#123; transition: opacity 1s ease;&#125;.router-view-enter-to&#123; opacity: 1;&#125;.router-view-leave&#123; opacity: 1;&#125;.router-view-leave-active&#123; transition: opacity 1s ease;&#125;.router-view-leave-to&#123; opacity: 0;&#125; 这些设置，每个页面的效果都是一样的，要为不同的页面设置不同的效果，可用路由传递相应的参数来，让动态绑定到 transition 的 name 属性上。 或者监听路由变化： 123456watch: &#123; '$route'(to)&#123; console.log(to); to.params&amp;&amp;to.params.view&amp;&amp;(this.effect = to.params.view) &#125;,&#125; 参考 Vue.js - 路由 vue-router 的使用详解2（参数传递）]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 路由基础]]></title>
    <url>%2F2019%2F05%2F25%2Fvue%20%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[vue 使用 vue-router 插件处理路由，路由是开发单页应用必须掌握的知识。 [TOC] 什么是 vue-router？ （1）vue-router 是 Vue 官方提供前端路由插件，借助它我们实现可以基于路由和组件的单页面应用。 （2）它与传统的页面区别在于： 传统的页面应用采用的是后端路由，即通过超链接来实现页面切换和跳转的。 而在 vue-router 单页面应用中，则是通过路径之间的切换（实际上就是组件的切换）。 router-link 和 router-view 组件 router-link 是一个a（链接）标签的封装，router-view 是路由视图，渲染 router-link 匹配到的组件，可配合使用&lt;transition&gt; 和 &lt;keep-alive&gt; 使用。 更多详细信息 路由配置 动态路由 $route 是当前路由，可用watch在组件中监它的变化，有一个 params 属性，值一个包含动态路由的对象。 1234567watch: &#123; '$route'(to) &#123; console.log(to); //将路由的 params 属性赋值给组件的 data 属性 to.params &amp;&amp; to.params.view &amp;&amp; (this.effect = to.params.view) &#125;,&#125; route 和 router 的区别 路由对象为： 12345&#123; path:'/argu/:name', // 使用 import 动态引入路径对应的组件，起到懒加载的作用 component:()=&gt;import('@/views/ArguPage')&#125; 可在该路由的组件中这样获取name的值： 1$route.params.name //给同一个组件设置传递不同的params，实现组件的复用 嵌套路由 在路由对象中添加一个 children 属性，值是一个数组，可包含多个子路由。子路由 path 前面不能有 / 。 父级路由对应的组件必须有路由出口，即 router-view。 命名路由 路由对象中的 name 属性是路由的名字，可用该名字指定路径。 在 router-link 的 to 属性动态绑定 路由对象。 1&lt;router-link :to="&#123;name:'home'&#125;"&gt;&lt;/router-link&gt; 命名视图 route-view 是路由视图，只有一个视图时，路由匹配的组件在该视图中渲染，多个视图则要对视图进行命名。 12345&lt;!-- 视图渲染组件,该组件内不需要房子任何内容，可写成只闭合标签--&gt;&lt;router-view /&gt;&lt;!-- 有多个路由视图需要匹配，则用命名视图 --&gt;&lt;router-view name="sister"&gt;&lt;/router-view&gt;&lt;router-view name="brother"&gt;&lt;/router-view&gt; 路由对象： 1234567891011&#123; path:'/name/view', name:'name_view', // 注意命名视图的 components 和 组件的 component 的区别 components:&#123; // 不给 router-view 设置 name 属性，name 值就是 default default:()=&gt;import('@/views/ChildPage'), sister:()=&gt;import('@/views/SisterPage'), brother:()=&gt;import('@/views/BrotherPage'), &#125;&#125; JS 操作路由 路由对象 $router 有多个函数push、go、replace push 可导航到不同的页面，会将该路径进入历史记录。 $router.push 和 window.history.pushSate 一样。 push 可接受不同的参数： 12345678910111213//字符串路径this.$router.push('home')// 路由对象this.$router.push(&#123;path:'home'&#125;)// 命名路由加参数this.$router.push(&#123;name:'argu',params:&#123;name:'jack'&#125;&#125;)// path 路由和 querythis.$router.push(&#123;path:'argu',query:&#123;name:'jack'&#125;&#125;);// path 和 params 不可一起使用，params 会被忽略this.$router.push(&#123;path:'argu',params:&#123;name:'jack'&#125;&#125;);this.$router.push(&#123;name:'argu',query:&#123;name:'jack'&#125;&#125;); go 的参数是一个整数，表示回退或者前进多少历史记录。 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()$router.go(1)// 后退一步记录，等同于 history.back()$router.go(-1)// 前进 3 步记录$router.go(3)// 如果 history 记录不够用，那就默默地失败呗$router.go(-100)$router.go(100) router.replace(location) = window.history.replaceState 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录 使用场景：不需要用户回退的情况，比如权限验证。 1234567891011// 路由名字this.$router.replace('name_view');// 字符串路径this.$router.replace('/name/view');// 路由对象this.$router.replace(&#123;path:'/name/view'&#125;);// 命名路由带 params this.$router.replace(&#123;name:'name_view',params:&#123;age:24&#125;&#125;);// path 和 querythis.$router.replace(&#123;path:'name_view',query:&#123;age:24&#125;&#125;);// this.$router.replace(&#123;path:'/name/view',params:&#123;age:24&#125;&#125;); 重定向和别名 12345// 路由重定向:访问 /index ，重定向到 /&#123; path:'/index', redirect:'/'&#125; redirect 也可设置一个对象： 123456&#123; path:'/index', redirect:&#123; name:'home' &#125;&#125; redirect 还可以设置为一个函数，传递一个参数 to,可根据该对象的不同值，重定向到不同的页面，返回一个 命名路由 或者 字符串路径 。 123456789&#123; path:'/index', redirect:to=&gt;&#123; // do something with to return &#123; name:'home' &#125; &#125;&#125; to 是一个包含路径参数的对象： 123456789101112131415161718192021&#123; name: "index", meta: &#123;&#125;,// 路由元数据，可在全局导航守卫中获取该对象，然后不同页面设置不同的值，比如设置页面的标题 path: "/index", // 路由路径 解析为绝对路径 /a/b hash: "", // 书签 query: &#123;&#125;, // 查询参数 /a?user=jack, $route.query.uer 的值为 jack params: &#123;&#125;, // fullPath: "/index", // 完整路径 matched: [&#123; // 当前路由的所有嵌套路径片段的路由记录,路由记录就是路由的副本。 path: "/index", regex: &#123; keys: [] &#125;, components: &#123;&#125;, instances: &#123;&#125;, name: "index", meta: &#123;&#125;, props: &#123;&#125; &#125;], redirectedForm:''// 重定向来源的名字&#125; 1234567891011router.beforeEach((to, from, next) =&gt; &#123; console.log('①，全局前置守卫,beforeEach'); //给每个页面设置不同的标题，标题就从 meta 中获取 //setTitle = (title)=&gt;&#123; // window.document.title=title||'admin' //&#125; to.meta &amp;&amp; setTitle(to.meta.title); next(()=&gt;&#123; console.log('②，全局前置守卫,beforeEach'); &#125;);&#125;); 路径别名 123456&#123; name: 'home', alias:'home_page',// 路径别名 path: '/', component: Home&#125;]]></content>
      <categories>
        <category>vue</category>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 使用教程]]></title>
    <url>%2F2019%2F05%2F18%2FNPM-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ npm 是npm包托管组织开发的 node 包管理工具，使用它可下载、卸载、更新、发布 npm 包，从而实现代码的共享和复用，node 开发必须掌握，前端工程化基于 node，因此，npm 技能是前端必须知道的。安装了 node，npm就集成在里面了，无需另外安装。 NPM 是什么 npm (node packge manager) ，node 包管理工具，主要功能就是管理node包：安装、卸载、更新、查看、搜索、发布等。 npm 的背后，有一个 couchdb（一个json数据库或者非关系型数据库）,详细记录了每个包的信息：作者、版本、依赖、授权信息等。 npm的重要作用：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，专注功能开发，建立了一个node生态圈，实现node代码共享、复用。 NPM官网 1234567891011npm install npm@latest -g #更新 npmnpm help # 帮助命令npm &lt;command&gt; -h #某条命令的用法npm -v #版本信息npm -l #常用命令信息npm config list #npm 配置信息npm config list -l # 默认配置信息列表npm init #初始化 package.json文件npm init -y #初始化 package.json 跳过询问npm init --yesnpm ls # 查看当前包的依赖 依赖名称注意事项： 不与 node 核心模块同名； 不得使用 js 或者 node name 会成为url、命令行、或者一个文件夹的名，非法url字符不允许，不以_或.开头 不得含有大写字母 配置相关： 1234npm config set key valuenpm config get keynpm config get prefix # 查看npm安装前缀npm config get cache # npm 缓存目录 NPM能做什么 安装模式 本地安装 vs 全局安装 本地安装：package会下载到当前目录的node_modules文件夹内，只能在当前目录下使用，一个项目使用到的依赖，采用本地安装。 全局安装：package会被下载到特定的系统目录的node_modules文件夹内，在所有目录下都能使用。在安装命令行后加-g选项，表示全局安装。工具包、很多项目都可能使用的包，全局安装。 全局模式和本地模式的比较： 模式 通过require 获取 注册环境变量path 本地模式 是 否 全局模式 否 是 查看安装目录： 12npm root npm root -g 语义化版本 更好的使用NPM NPM 使用技巧 yarn 使用 依赖锁文件 NPM中的package锁 安装 主要关注安装的版本号和安装成哪个依赖项目（开发依赖、运行时依赖（线上依赖）、可选依赖等）。 npm 会先检查是否安装了该模块，已经安装，则更新版本。 12345678npm i # 安装 package.json 所有依赖（开发依赖、运行时依赖、对等依赖等）npm i -E packageName # 安装精确版本 推荐用法npm i packegeName # 默认安装成产品依赖最新版本npm i packageName1 packageName2 # 安装多个依赖npm install packageName # 保存在 dependenciesnpm i getHub-rpo #从github 仓库安装包# 查看当前目录有哪些文件 类似 Linux 的 lsdir 强制安装： 1npm i packageName -f #不检查是否安装，直接安装 可指定安装版本和使用的范围 12345npm i packeageName@x.y.z -D # 安装该模块的x.y.z版本为开发依赖npm i packageName@~x.y.z # 安装该版本的近似版本npm i packageName@^x.y.z # 安装兼容版本npm i packageName@x.y.x # 不提供z版本号，安装最新的 x.y 版本npm i packageName # 安装最新版本 在本地安装的同时，将依赖包的信息（要求的名称和版本）写入package.json中是很重要的！ 123456npm install packageName #安装后默认写入package.json中 dependencies 中npm i packageName --no-save # 安装依赖，但不写入package.jsonnpm install packageName --save #安装好后写入package.json的 dependencies中（生产环境依赖）npm install packageName -S #安装好后写入package.json的dependencies中（生产环境依赖）npm install packageName -D #安装好后写入package.json的devDependencies中（开发环境依赖）npm install packageName --save-dev #安装好后写入package.json的devDependencies中（开发环境依赖） 一个模块要么是开发依赖，要么是产品依赖，不可能同时是两种依赖。 在 package.json内部声明需要安装的模块。然后 npm i可以安装。 卸载 1234npm rm packageName #同时删除 package.json 中的 dependencies或devDependencies 的依赖信息npm rm packageName --no-save # 删除依赖，但是不删除 package.json 文件中依赖的信息npm un packageNamenpm uninstall packageName 还可指定卸载的版本。 查看过时的依赖 1npm outdated # 会列出过时的依赖 更新 123npm update packageName# 可指定更新到某一特定版本# 会先检查远程版本，远程版本较新，则安装。 查看模块依赖 123456789#参看模块依赖npm ls --depth 0 # 或者npm list --depth=n# --depth n 输出依赖的树形结构的层级深度# 0 不显示依赖 1 显示一级依赖# 查看特定模块npm ls packageNamepackageName -v # 依赖版本号 修复安全问题 要求 npm@6.x 以后的版本 123npm audit # 显示安全问题npm aduti fix # 修复安全问题npm aduti fix -f # 强制修复 更多信息： What is npm audit fix??? Auditing package dependencies for security vulnerabilities 模块信息 12345678910npm info packageName# 输出的信息是一个 json格式的，比 package.json 描述文件提供更多的信息。npm view packageNamenpm view packageName engines # 模块需要的 node 版本npm list packageName version # 当前项目总用到的模块的版本npm v packageName npm show packageNamenpm show packageName versions # 查看所有发布的版本npm show pacheageName version #查看最新版本npm show packageName time #各个版本发布的时间 查看依赖文档 1npm docs packageName # 会在浏览器里打开依赖文档 查看依赖 bug 1npm bugs packageName # 会打开 bugs 页面 搜索模块 记不住依赖确切名字是搜索。 123npm find packageName # 查找模块报错 ，可能是源不对。改为官方源。npm s packageNamenpm search packageName npm 源管理 安装 nrm模块来管理 npm 源，方便。 123nrm -h # nrm 命令帮助信息nrm ls # 所有registriesnrm use regNmae # 使用某个reg 源 其他源管理方法： 1npm config set registry url # 将 url 设置为 npm 源 npm 缓存管理 使用 npm 缓存，可提升安装速度，因为 npm 会把你安装过的模块缓存下来，下次安装先读缓存，缓存功能是默认关闭的。 12npm config set cache path -g #path 是绝对路径，这样就开启缓存了npm cache clean #清除缓存 问题 package.json 的name为webpack，在尝试安装webpack 时报错。 123npm ERR! Refusing to install package with name "webpack" under a packagenpm ERR! also called "webpack". Did you name your project the samenpm ERR! as the dependency you're installing? 后查阅资料，得知npm会拒绝安装与本地包相同名字的包，因为这样可能是依赖查找算法无限循环。修改package.json 的name属性即可。所以给项目起名字时记得取一个特殊的名字，以免与你将要安装的包冲突。 引入 npm 是大小写弄错，会报以下警告： 123There are multiple modules with names that only differ in casing.This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.Use equal casing. Compare these module identifiers: 有多个模块名字相同，但是名字大小写不同。在同一个问价系统中使用，可能会导致不可预期的行为。 配置 script 命令 在 package.json 文件的 script字段里，可设置 npm 运行脚本的命令。 12345"script": &#123; "start": "node ./bin/www", "test": "node ./test.js" "dev": "nodemon ./bin/www"&#125; 执行命令： 123456npm run start # 会执行 node ./bin/wwwnpm run dev # 执行 nodemon ./bin/www# start 和 test 比较特殊，可不加 run start 和 test 本身是 npm 命令npm startnpm testnpm t # 和 npm test 相同 npm i package_name &lt;options&gt; 命令选项 -v: --version -h, -?, --help, -H: --usage 帮助信息 -s, --silent: --loglevel silent -q, --quiet: --loglevel warn -d: --loglevel info -dd, --verbose: --loglevel verbose -ddd: --loglevel silly -g: --global 全局命令 -C: --prefix -l: --long -m: --message -p, --porcelain: --parseable -reg: --registry -f: --force 强制执行 -desc: --description -S --save 生产依赖 -P: --save-prod 生产依赖 -D: --save-dev 开发依赖 -O: --save-optional 可选依赖 -B: --save-bundle -E: --save-exact 精确安装指定模块版本 -y: --yes 使用默认值 -n: --yes false ll and la commands: ls --long 更多命苦 npm cli commomd]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>node</tag>
      </tags>
  </entry>
</search>
